<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find The Button 4D üî¥</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Orbitron', sans-serif;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* Menu Screen */
        #menuScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 40%, #16213e 70%, #0f3460 100%);
            z-index: 100;
        }

        #menuScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 80%, rgba(233, 69, 96, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(79, 172, 254, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.02) 0%, transparent 60%);
            animation: bgPulse 8s ease-in-out infinite;
        }

        @keyframes bgPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        /* Floating particles */
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: float 15s infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                transform: translateY(-100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .menu-content {
            position: relative;
            z-index: 1;
            text-align: center;
        }

        .game-title {
            font-size: 4.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #e94560 0%, #ff6b6b 50%, #feca57 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            margin-bottom: 0.5rem;
            letter-spacing: 4px;
            animation: titleGlow 3s ease-in-out infinite;
            filter: drop-shadow(0 0 30px rgba(233, 69, 96, 0.5));
        }

        @keyframes titleGlow {

            0%,
            100% {
                filter: drop-shadow(0 0 30px rgba(233, 69, 96, 0.5));
            }

            50% {
                filter: drop-shadow(0 0 50px rgba(233, 69, 96, 0.8));
            }
        }

        .subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.8rem;
            color: #4facfe;
            margin-bottom: 3rem;
            letter-spacing: 8px;
            text-transform: uppercase;
            opacity: 0.9;
        }

        .level-select-title {
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 1.5rem;
            letter-spacing: 3px;
        }

        /* Chapter Selection Styles */
        .chapter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
            max-width: 900px;
        }

        .chapter-btn {
            padding: 1.5rem 2rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            border: 3px solid;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 160px;
            text-align: center;
            border-radius: 10px;
        }

        .chapter-btn:hover {
            transform: scale(1.05);
        }

        .chapter-btn .chapter-icon {
            font-size: 2rem;
            display: block;
            margin-bottom: 0.5rem;
        }

        .chapter-btn .chapter-name {
            font-size: 0.9rem;
            display: block;
        }

        .chapter-btn .chapter-difficulty {
            font-size: 0.7rem;
            opacity: 0.7;
            display: block;
            margin-top: 0.3rem;
        }

        /* Chapter 1 - Vert Nature */
        .chapter-btn.chapter1 {
            color: #4ade80;
            border-color: #4ade80;
        }

        .chapter-btn.chapter1:hover {
            background: rgba(74, 222, 128, 0.2);
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.5);
        }

        /* Chapter 2 - Orange Sauvage */
        .chapter-btn.chapter2 {
            color: #fb923c;
            border-color: #fb923c;
        }

        .chapter-btn.chapter2:hover {
            background: rgba(251, 146, 60, 0.2);
            box-shadow: 0 0 30px rgba(251, 146, 60, 0.5);
        }

        /* Chapter 3 - Bleu Ancien */
        .chapter-btn.chapter3 {
            color: #60a5fa;
            border-color: #60a5fa;
        }

        .chapter-btn.chapter3:hover {
            background: rgba(96, 165, 250, 0.2);
            box-shadow: 0 0 30px rgba(96, 165, 250, 0.5);
        }

        /* Chapter 4 - Rouge Hostile */
        .chapter-btn.chapter4 {
            color: #f87171;
            border-color: #f87171;
        }

        .chapter-btn.chapter4:hover {
            background: rgba(248, 113, 113, 0.2);
            box-shadow: 0 0 30px rgba(248, 113, 113, 0.5);
        }

        /* Chapter 5 - Violet Mystique */
        .chapter-btn.chapter5 {
            color: #c084fc;
            border-color: #c084fc;
        }

        .chapter-btn.chapter5:hover {
            background: rgba(192, 132, 252, 0.2);
            box-shadow: 0 0 30px rgba(192, 132, 252, 0.5);
        }

        .back-btn {
            padding: 0.8rem 2rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            border: 2px solid #888;
            background: rgba(255, 255, 255, 0.05);
            color: #888;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1.5rem;
            border-radius: 5px;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border-color: #fff;
        }

        #chapterScreen,
        #levelSelectScreen {
            display: none;
        }

        .level-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            justify-content: center;
            margin-bottom: 2rem;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
        }

        .level-buttons::-webkit-scrollbar {
            width: 8px;
        }

        .level-buttons::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .level-buttons::-webkit-scrollbar-thumb {
            background: #4facfe;
            border-radius: 4px;
        }

        .level-btn {
            padding: 0.6rem 1rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            font-weight: 700;
            border: 2px solid;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            min-width: 100px;
            z-index: 1;
        }

        .level-btn>* {
            position: relative;
            z-index: 2;
            pointer-events: none;
        }

        .level-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            transition: left 0.3s ease;
            z-index: 0;
            pointer-events: none;
        }

        .level-btn:hover::before {
            left: 0;
        }

        /* Tr√®s facile - Vert */
        .level-btn.easy {
            color: #4ade80;
            border-color: #4ade80;
        }

        .level-btn.easy::before {
            background: #4ade80;
        }

        .level-btn.easy:hover,
        .level-btn.easy.selected {
            color: #0a0a0f;
            background: #4ade80;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
        }

        /* Facile - Vert clair */
        .level-btn.easy2 {
            color: #86efac;
            border-color: #86efac;
        }

        .level-btn.easy2::before {
            background: #86efac;
        }

        .level-btn.easy2:hover,
        .level-btn.easy2.selected {
            color: #0a0a0f;
            background: #86efac;
            box-shadow: 0 0 20px rgba(134, 239, 172, 0.5);
        }

        /* Moyen-facile - Cyan */
        .level-btn.medium1 {
            color: #22d3d9;
            border-color: #22d3d9;
        }

        .level-btn.medium1::before {
            background: #22d3d9;
        }

        .level-btn.medium1:hover,
        .level-btn.medium1.selected {
            color: #0a0a0f;
            background: #22d3d9;
            box-shadow: 0 0 20px rgba(34, 211, 217, 0.5);
        }

        /* Moyen - Bleu */
        .level-btn.medium2 {
            color: #60a5fa;
            border-color: #60a5fa;
        }

        .level-btn.medium2::before {
            background: #60a5fa;
        }

        .level-btn.medium2:hover,
        .level-btn.medium2.selected {
            color: #0a0a0f;
            background: #60a5fa;
            box-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
        }

        /* Moyen+ - Jaune */
        .level-btn.medium3 {
            color: #fbbf24;
            border-color: #fbbf24;
        }

        .level-btn.medium3::before {
            background: #fbbf24;
        }

        .level-btn.medium3:hover,
        .level-btn.medium3.selected {
            color: #0a0a0f;
            background: #fbbf24;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
        }

        /* Difficile - Orange */
        .level-btn.hard1 {
            color: #fb923c;
            border-color: #fb923c;
        }

        .level-btn.hard1::before {
            background: #fb923c;
        }

        .level-btn.hard1:hover,
        .level-btn.hard1.selected {
            color: #0a0a0f;
            background: #fb923c;
            box-shadow: 0 0 20px rgba(251, 146, 60, 0.5);
        }

        /* Difficile+ - Orange fonc√© */
        .level-btn.hard2 {
            color: #f97316;
            border-color: #f97316;
        }

        .level-btn.hard2::before {
            background: #f97316;
        }

        .level-btn.hard2:hover,
        .level-btn.hard2.selected {
            color: #0a0a0f;
            background: #f97316;
            box-shadow: 0 0 20px rgba(249, 115, 22, 0.5);
        }

        /* Tr√®s difficile - Rouge */
        .level-btn.hard3 {
            color: #ef4444;
            border-color: #ef4444;
        }

        .level-btn.hard3::before {
            background: #ef4444;
        }

        .level-btn.hard3:hover,
        .level-btn.hard3.selected {
            color: #0a0a0f;
            background: #ef4444;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
        }

        /* Extr√™me - Rouge fonc√© */
        .level-btn.extreme {
            color: #dc2626;
            border-color: #dc2626;
        }

        .level-btn.extreme::before {
            background: #dc2626;
        }

        .level-btn.extreme:hover,
        .level-btn.extreme.selected {
            color: #0a0a0f;
            background: #dc2626;
            box-shadow: 0 0 20px rgba(220, 38, 38, 0.5);
        }

        /* Final - Violet/Or */
        .level-btn.final {
            color: #a855f7;
            border-color: #a855f7;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(234, 179, 8, 0.1));
        }

        .level-btn.final::before {
            background: linear-gradient(135deg, #a855f7, #eab308);
        }

        .level-btn.final:hover,
        .level-btn.final.selected {
            color: #0a0a0f;
            background: linear-gradient(135deg, #a855f7, #eab308);
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.6);
        }

        .play-btn {
            padding: 1.2rem 4rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: 4px;
            background: linear-gradient(135deg, #e94560 0%, #ff6b6b 100%);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(233, 69, 96, 0.4);
            z-index: 10;
        }

        .play-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 50px rgba(233, 69, 96, 0.6);
        }

        .play-btn:active {
            transform: translateY(0);
        }

        .controls-info {
            margin-top: 3rem;
            font-family: 'Rajdhani', sans-serif;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1rem;
            letter-spacing: 2px;
        }

        .controls-info span {
            color: #4facfe;
            font-weight: 700;
        }

        /* Game UI */
        #gameUI {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 50;
            pointer-events: none;
        }

        .ui-panel {
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(79, 172, 254, 0.3);
            padding: 15px 25px;
            border-radius: 10px;
        }

        .level-display {
            font-size: 1.5rem;
            color: #4facfe;
            letter-spacing: 2px;
        }

        .level-name {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
        }

        .hint-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.1rem;
            color: #feca57;
            letter-spacing: 1px;
        }

        #cameraBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            background: rgba(79, 172, 254, 0.2);
            border: 2px solid #4facfe;
            color: #4facfe;
            cursor: pointer;
            z-index: 50;
            transition: all 0.3s ease;
            display: none;
            pointer-events: auto;
        }

        #cameraBtn:hover {
            background: #4facfe;
            color: #0a0a0f;
        }

        #menuBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid #ef4444;
            color: #ef4444;
            cursor: pointer;
            z-index: 50;
            transition: all 0.3s ease;
            display: none;
            pointer-events: auto;
        }

        #menuBtn:hover {
            background: #ef4444;
            color: #0a0a0f;
        }

        /* Win Screen */
        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 15, 0.95);
            z-index: 200;
        }

        .win-title {
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 50%, #16a34a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            animation: winPulse 1s ease-in-out infinite;
        }

        @keyframes winPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .win-subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 2rem;
        }

        .win-buttons {
            display: flex;
            gap: 1.5rem;
        }

        .win-btn {
            padding: 1rem 2.5rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            border: 2px solid;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .win-btn.next {
            color: #4ade80;
            border-color: #4ade80;
        }

        .win-btn.next:hover {
            background: #4ade80;
            color: #0a0a0f;
        }

        .win-btn.menu {
            color: #4facfe;
            border-color: #4facfe;
        }

        .win-btn.menu:hover {
            background: #4facfe;
            color: #0a0a0f;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: none;
            z-index: 40;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
        }

        #crosshair::before {
            width: 2px;
            height: 8px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #crosshair::after {
            width: 8px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #crosshair.active {
            border-color: #e94560;
        }

        #crosshair.active::before,
        #crosshair.active::after {
            background: #e94560;
        }

        /* Button found indicator */
        #buttonIndicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            background: rgba(233, 69, 96, 0.9);
            color: white;
            border-radius: 10px;
            display: none;
            z-index: 60;
            animation: bounce 0.5s ease-in-out infinite;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(-10px);
            }
        }

        /* Timer */
        #timer {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: #4facfe;
            z-index: 50;
            display: none;
            text-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
        }
    </style>
</head>

<body>
    <div id="gameContainer"></div>

    <!-- Menu Screen - Chapter Selection -->
    <div id="menuScreen">
        <div class="menu-content">
            <h1 class="game-title">FIND THE BUTTON</h1>
            <p class="subtitle">4D EDITION</p>

            <p class="level-select-title">S√âLECTIONNE UN CHAPITRE</p>
            <div class="chapter-buttons">
                <button class="chapter-btn chapter1" data-chapter="1">
                    <span class="chapter-icon">üåø</span>
                    <span class="chapter-name">Prairies Verdoyantes</span>
                    <span class="chapter-difficulty">Facile ‚Ä¢ 20 niveaux</span>
                </button>
                <button class="chapter-btn chapter2" data-chapter="2">
                    <span class="chapter-icon">üèúÔ∏è</span>
                    <span class="chapter-name">Terres Sauvages</span>
                    <span class="chapter-difficulty">Moyen ‚Ä¢ 20 niveaux</span>
                </button>
                <button class="chapter-btn chapter3" data-chapter="3">
                    <span class="chapter-icon">üèõÔ∏è</span>
                    <span class="chapter-name">Royaumes Anciens</span>
                    <span class="chapter-difficulty">Difficile ‚Ä¢ 20 niveaux</span>
                </button>
                <button class="chapter-btn chapter4" data-chapter="4">
                    <span class="chapter-icon">üåã</span>
                    <span class="chapter-name">Mondes Hostiles</span>
                    <span class="chapter-difficulty">Tr√®s Difficile ‚Ä¢ 20 niveaux</span>
                </button>
                <button class="chapter-btn chapter5" data-chapter="5">
                    <span class="chapter-icon">üß©</span>
                    <span class="chapter-name">√ânigmes Mystiques</span>
                    <span class="chapter-difficulty">Expert ‚Ä¢ 20 puzzles</span>
                </button>
            </div>

            <div class="controls-info">
                <span>‚Üë‚Üì‚Üê‚Üí</span> ou <span>WASD</span> D√©placer &nbsp;|&nbsp;
                <span>ESPACE</span> Sauter &nbsp;|&nbsp;
                <span>CLIC</span> Interagir
            </div>
        </div>

        <!-- Particles -->
        <div class="particle" style="left: 10%; animation-delay: 0s;"></div>
        <div class="particle" style="left: 20%; animation-delay: 2s;"></div>
        <div class="particle" style="left: 30%; animation-delay: 4s;"></div>
        <div class="particle" style="left: 40%; animation-delay: 1s;"></div>
        <div class="particle" style="left: 50%; animation-delay: 3s;"></div>
        <div class="particle" style="left: 60%; animation-delay: 5s;"></div>
        <div class="particle" style="left: 70%; animation-delay: 2.5s;"></div>
        <div class="particle" style="left: 80%; animation-delay: 4.5s;"></div>
        <div class="particle" style="left: 90%; animation-delay: 1.5s;"></div>
    </div>

    <!-- Level Selection Screen (per chapter) -->
    <div id="levelSelectScreen"
        style="position:fixed;top:0;left:0;width:100vw;height:100vh;display:none;flex-direction:column;justify-content:center;align-items:center;background:linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 40%, #16213e 70%, #0f3460 100%);z-index:100;">
        <div class="menu-content">
            <button class="back-btn" id="backToChaptersBtn">‚Üê Retour aux chapitres</button>
            <h2 class="level-select-title" id="chapterTitle">CHAPITRE 1</h2>
            <div class="level-buttons" id="levelButtonsContainer">
                <!-- Levels will be generated by JavaScript -->
            </div>
            <button class="play-btn" id="playLevelBtn">JOUER</button>
        </div>
    </div>

    <!-- Game UI -->
    <div id="gameUI">
        <div class="ui-panel">
            <div class="level-display">NIVEAU <span id="currentLevel">1</span></div>
            <div class="level-name" id="levelName">For√™t Paisible</div>
        </div>
        <div class="ui-panel">
            <div class="hint-text" id="hintText">Trouve le bouton rouge cach√© !</div>
        </div>
    </div>

    <div id="timer">00:00</div>
    <div id="crosshair"></div>
    <div id="buttonIndicator" style="display:none !important;"></div>
    <div id="keyIndicator"
        style="position:fixed;bottom:100px;left:50%;transform:translateX(-50%);padding:15px 30px;font-family:'Orbitron',sans-serif;font-size:1.2rem;background:rgba(255,215,0,0.9);color:#333;border-radius:10px;display:none;z-index:60;animation:bounce 0.5s ease-in-out infinite;">
        üîë CLIC ou ENTR√âE pour prendre la cl√© !</div>
    <div id="doorIndicator"
        style="position:fixed;bottom:100px;left:50%;transform:translateX(-50%);padding:15px 30px;font-family:'Orbitron',sans-serif;font-size:1.2rem;background:rgba(139,69,19,0.9);color:white;border-radius:10px;display:none;z-index:60;animation:bounce 0.5s ease-in-out infinite;">
        üö™ CLIC ou ENTR√âE pour ouvrir la porte !</div>
    <button id="cameraBtn">üì∑ VUE 3√àME PERSONNE</button>
    <button id="menuBtn">MENU</button>

    <!-- Win Screen -->
    <div id="winScreen">
        <h1 class="win-title">BRAVO !</h1>
        <p class="win-subtitle">Tu as trouv√© le bouton en <span id="winTime">00:00</span> !</p>
        <div class="win-buttons">
            <button class="win-btn next" id="nextLevelBtn">NIVEAU SUIVANT</button>
            <button class="win-btn menu" id="backToMenuBtn">MENU</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        let scene, camera, renderer, player, redButton;
        let nextButtonPos = { x: 0, z: 0 }; // Position du bouton √† venir (pour √©viter de le couvrir)
        let currentChapter = 1;
        let currentLevel = 1;
        let selectedChapter = 1;
        let selectedLevel = 1;
        let isPlaying = false;
        let cameraYaw = 0; // Angle horizontal libre (rotation souris)
        let cameraPitch = 0.3; // Angle vertical
        let cameraDistance = 10;
        let cameraHeight = 6;
        let isFirstPerson = false; // true = vue 1√®re personne, false = vue 3√®me personne
        let isRightMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Animation de marche
        let leftLegPivot, rightLegPivot, leftArmPivot, rightArmPivot;
        let walkAnimationTime = 0;
        let isWalking = false;
        let timerStart = 0;
        let timerInterval = null;
        let canPressButton = false;
        let levelObjects = [];
        let platforms = [];
        let solidObjects = []; // Objets avec collision

        // Player controls
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyW: false,
            KeyA: false,
            KeyS: false,
            KeyD: false,
            Space: false
        };

        // Player physics
        let playerVelocity = { x: 0, y: 0, z: 0 };
        const playerSpeed = 0.15;
        const jumpForce = 0.3;
        const gravity = 0.015;
        let isGrounded = true;

        // Variables pour le niveau 20 (cl√© et porte)
        let level20Key = null;
        let level20Door = null;
        let level20Rock = null;
        let level20RockCollision = null; // Pour pouvoir supprimer la collision
        let hasKey = false;
        let doorOpened = false;
        let level20ButtonHidden = true;

        // Puzzle objects for Chapter 5
        let puzzleObjects = {
            switches: [],
            gems: [],
            torches: [],
            keys: [],
            doors: [],
            lever: null,
            pushableRock: null,
            breakableWall: null,
            runes: [],
            pillars: [],
            ghost: null,
            seed: null,
            waterSource: null,
            codePanel: null,
            plates: [],
            crystals: [],
            map: null,
            stars: []
        };

        // Puzzle state
        let puzzleState = {
            switches: [false, false, false],
            switchOrder: [],
            gems: [false, false, false],
            gemsCollected: 0,
            torches: [false, false, false],
            torchesLit: 0,
            keys: [false, false],
            keysCollected: 0,
            doors: [false, false],
            doorsOpened: 0,
            runesCollected: 0,
            leverPulled: false,
            rockPushed: false,
            wallBroken: false,
            codeEntered: false,
            currentCode: "",
            correctCode: "1234",
            plateSequence: [],
            correctPlateSequence: [1, 3, 2, 4],
            crystalOrder: [],
            correctCrystalOrder: ["red", "blue", "green", "yellow"],
            mapFound: false,
            waterReleased: false,
            pillarsAligned: [false, false, false],
            ghostFollowed: false,
            seedPlanted: false,
            seedWatered: false,
            treeGrown: false,
            mazeCompleted: false,
            starsAligned: false,
            ultimateSteps: 0
        };

        // Level configurations - 100 niveaux
        // Chapter definitions
        const chapterInfo = {
            1: { name: "Prairies Verdoyantes", icon: "üåø", color: "#4ade80" },
            2: { name: "Terres Sauvages", icon: "üèúÔ∏è", color: "#fb923c" },
            3: { name: "Royaumes Anciens", icon: "üèõÔ∏è", color: "#60a5fa" },
            4: { name: "Mondes Hostiles", icon: "üåã", color: "#f87171" },
            5: { name: "√ânigmes Mystiques", icon: "üß©", color: "#c084fc" }
        };

        // All 100 level configurations organized by chapter
        const levelConfigs = {
            // CHAPITRE 1: Prairies Verdoyantes (Facile) - 20 niveaux
            // difficulty: 'easy' = bouton derri√®re UN objet, tr√®s visible
            "1-1": { name: "Jardin Fleuri", hint: "Regarde derri√®re les buissons...", groundColor: 0x3d8b37, skyColor: 0x87ceeb, fogColor: 0x87ceeb, fogDensity: 0.015, buttonPos: { x: 15, y: 0.5, z: 12 }, levelType: "garden", difficulty: "easy" },
            "1-2": { name: "Prairie Calme", hint: "Parmi les hautes herbes...", groundColor: 0x58d68d, skyColor: 0xaed6f1, fogColor: 0xaed6f1, fogDensity: 0.015, buttonPos: { x: -18, y: 0.5, z: 20 }, levelType: "meadow", difficulty: "easy" },
            "1-3": { name: "Clairi√®re Ensoleill√©e", hint: "Au milieu des arbres...", groundColor: 0x4caf50, skyColor: 0x87ceeb, fogColor: 0x87ceeb, fogDensity: 0.012, buttonPos: { x: 22, y: 0.5, z: -15 }, levelType: "clearing", difficulty: "easy" },
            "1-4": { name: "Pr√© aux Papillons", hint: "Pr√®s des fleurs color√©es...", groundColor: 0x66bb6a, skyColor: 0xb3e5fc, fogColor: 0xb3e5fc, fogDensity: 0.01, buttonPos: { x: -25, y: 0.5, z: 30 }, levelType: "butterfly", difficulty: "easy" },
            "1-5": { name: "Vall√©e Verte", hint: "Dans le creux de la vall√©e...", groundColor: 0x43a047, skyColor: 0x90caf9, fogColor: 0x90caf9, fogDensity: 0.018, buttonPos: { x: 35, y: 0.5, z: -25 }, levelType: "valley", difficulty: "easy" },
            "1-6": { name: "Collines Douces", hint: "Sur les douces collines...", groundColor: 0x81c784, skyColor: 0x81d4fa, fogColor: 0x81d4fa, fogDensity: 0.015, buttonPos: { x: -30, y: 0.5, z: -28 }, levelType: "hills", difficulty: "easy" },
            "1-7": { name: "Jardin Secret", hint: "Un lieu cach√©...", groundColor: 0x2e7d32, skyColor: 0xa5d6a7, fogColor: 0xa5d6a7, fogDensity: 0.02, buttonPos: { x: 37.5, y: 0.5, z: -40 }, levelType: "secretgarden", difficulty: "none" },
            "1-8": { name: "Plaine Paisible", hint: "Parmi les buissons...", groundColor: 0x7cb342, skyColor: 0xc5e1a5, fogColor: 0xc5e1a5, fogDensity: 0.012, buttonPos: { x: 25, y: 0.5, z: -20 }, levelType: "plain", difficulty: "easy" },
            "1-9": { name: "Bosquet Tranquille", hint: "Entre les arbustes...", groundColor: 0x558b2f, skyColor: 0xdcedc8, fogColor: 0xdcedc8, fogDensity: 0.02, buttonPos: { x: 18, y: 0.5, z: 28 }, levelType: "grove", difficulty: "easy" },
            "1-10": { name: "Champs de Fleurs", hint: "Parmi les fleurs...", groundColor: 0x8bc34a, skyColor: 0xf0f4c3, fogColor: 0xf0f4c3, fogDensity: 0.01, buttonPos: { x: 30, y: 0.5, z: -25 }, levelType: "flowerfield", difficulty: "easy" },
            "1-11": { name: "Pelouse du Ch√¢teau", hint: "Devant les grandes portes...", groundColor: 0x689f38, skyColor: 0xe8f5e9, fogColor: 0xe8f5e9, fogDensity: 0.015, buttonPos: { x: 35, y: 0.5, z: -18 }, levelType: "castlelawn", difficulty: "easy" },
            "1-12": { name: "P√¢turage Serein", hint: "O√π paissent les moutons...", groundColor: 0x9ccc65, skyColor: 0xbbdefb, fogColor: 0xbbdefb, fogDensity: 0.012, buttonPos: { x: -32, y: 0.5, z: 22 }, levelType: "pasture", difficulty: "easy" },
            "1-13": { name: "Verger Printanier", hint: "Sous les arbres fruitiers...", groundColor: 0xaed581, skyColor: 0xfce4ec, fogColor: 0xfce4ec, fogDensity: 0.015, buttonPos: { x: 28, y: 0.5, z: 30 }, levelType: "orchard", difficulty: "easy" },
            "1-14": { name: "Jardin Zen", hint: "Dans la paix du jardin...", groundColor: 0xc5cae9, skyColor: 0xe3f2fd, fogColor: 0xe3f2fd, fogDensity: 0.01, buttonPos: { x: -30, y: 0.5, z: -28 }, levelType: "zen", difficulty: "easy" },
            "1-15": { name: "Prairie Brumeuse", hint: "Cach√©e dans la brume...", groundColor: 0xa5d6a7, skyColor: 0xcfd8dc, fogColor: 0xcfd8dc, fogDensity: 0.035, buttonPos: { x: 38, y: 0.5, z: 12 }, levelType: "mistymeadow", difficulty: "easy" },
            "1-16": { name: "Clairi√®re Magique", hint: "Un lieu enchant√©...", groundColor: 0x4db6ac, skyColor: 0xb2dfdb, fogColor: 0xb2dfdb, fogDensity: 0.02, buttonPos: { x: -28, y: 0.5, z: 0 }, levelType: "magicclearing", difficulty: "easy" },
            "1-17": { name: "Vall√©e des F√©es", hint: "O√π vivent les f√©es...", groundColor: 0x80cbc4, skyColor: 0xe0f7fa, fogColor: 0xe0f7fa, fogDensity: 0.015, buttonPos: { x: -25, y: 0.5, z: 28 }, levelType: "fairyvalley", difficulty: "easy" },
            "1-18": { name: "Pr√© Enchant√©", hint: "Un lieu de magie...", groundColor: 0x26a69a, skyColor: 0xb2ebf2, fogColor: 0xb2ebf2, fogDensity: 0.018, buttonPos: { x: -38, y: 0.5, z: -30 }, levelType: "enchanted", difficulty: "easy" },
            "1-19": { name: "Jardin du Paradis", hint: "Le plus beau jardin...", groundColor: 0x00897b, skyColor: 0x80deea, fogColor: 0x80deea, fogDensity: 0.012, buttonPos: { x: 42, y: 0.5, z: 20 }, levelType: "paradise", difficulty: "easy" },
            "1-20": { name: "Prairie √âternelle", hint: "Le secret de la prairie...", groundColor: 0x00796b, skyColor: 0x4dd0e1, fogColor: 0x4dd0e1, fogDensity: 0.015, buttonPos: { x: -40, y: 0.5, z: 38 }, levelType: "eternal", difficulty: "easy" },

            // CHAPITRE 2: Terres Sauvages (Moyen) - 20 niveaux
            // difficulty: 'medium' = bouton entre plusieurs objets, 100% visible
            "2-1": { name: "For√™t Dense", hint: "Entour√© d'arbres...", groundColor: 0x2d5a27, skyColor: 0x87ceeb, fogColor: 0x87ceeb, fogDensity: 0.02, buttonPos: { x: 25, y: 0.5, z: 18 }, levelType: "forest", difficulty: "medium" },
            "2-2": { name: "Plage Tropicale", hint: "Entre les palmiers...", groundColor: 0xf4d03f, skyColor: 0x5dade2, fogColor: 0x5dade2, fogDensity: 0.012, buttonPos: { x: -28, y: 0.5, z: 20 }, levelType: "beach", difficulty: "medium" },
            "2-3": { name: "D√©sert Aride", hint: "Parmi les cactus...", groundColor: 0xe9c46a, skyColor: 0xf4d03f, fogColor: 0xf4d03f, fogDensity: 0.015, buttonPos: { x: 30, y: 0.5, z: -25 }, levelType: "desert", difficulty: "medium" },
            "2-4": { name: "Canyon Rocheux", hint: "Entre les rochers...", groundColor: 0xcd853f, skyColor: 0xffa07a, fogColor: 0xffa07a, fogDensity: 0.02, buttonPos: { x: -32, y: 0.5, z: -22 }, levelType: "canyon", difficulty: "medium" },
            "2-5": { name: "For√™t de Bambou", hint: "Au milieu des bambous...", groundColor: 0x2e7d32, skyColor: 0xa5d6a7, fogColor: 0xa5d6a7, fogDensity: 0.025, buttonPos: { x: 28, y: 0.5, z: 30 }, levelType: "bamboo", difficulty: "medium" },
            "2-6": { name: "Marais Brumeux", hint: "Dans la brume...", groundColor: 0x4a5d23, skyColor: 0x7f8c8d, fogColor: 0x7f8c8d, fogDensity: 0.04, buttonPos: { x: -35, y: 0.5, z: 25 }, levelType: "swamp", difficulty: "medium" },
            "2-7": { name: "Savane Africaine", hint: "Parmi les acacias...", groundColor: 0xd4a76a, skyColor: 0xffd54f, fogColor: 0xffd54f, fogDensity: 0.015, buttonPos: { x: 38, y: 0.5, z: -18 }, levelType: "savanna", difficulty: "medium" },
            "2-8": { name: "Jungle Profonde", hint: "Dans la v√©g√©tation dense...", groundColor: 0x1b5e20, skyColor: 0x4caf50, fogColor: 0x4caf50, fogDensity: 0.04, buttonPos: { x: -30, y: 0.5, z: -35 }, levelType: "jungle", difficulty: "medium" },
            "2-9": { name: "C√¥te Sauvage", hint: "Entre les rochers c√¥tiers...", groundColor: 0x8d6e63, skyColor: 0x78909c, fogColor: 0x78909c, fogDensity: 0.025, buttonPos: { x: 35, y: 0.5, z: 32 }, levelType: "coast", difficulty: "medium" },
            "2-10": { name: "Dunes de Sable", hint: "Parmi les dunes...", groundColor: 0xffcc80, skyColor: 0xffe0b2, fogColor: 0xffe0b2, fogDensity: 0.02, buttonPos: { x: -38, y: 0.5, z: 15 }, levelType: "dunes", difficulty: "medium" },
            "2-11": { name: "For√™t Amazonienne", hint: "Au c≈ìur de l'Amazonie...", groundColor: 0x33691e, skyColor: 0x7cb342, fogColor: 0x7cb342, fogDensity: 0.045, buttonPos: { x: 40, y: 0.5, z: -30 }, levelType: "amazon", difficulty: "medium" },
            "2-12": { name: "Oasis Cach√©e", hint: "Le refuge du d√©sert...", groundColor: 0xfff176, skyColor: 0xfff59d, fogColor: 0xfff59d, fogDensity: 0.018, buttonPos: { x: -35, y: 0.5, z: -38 }, levelType: "oasis", difficulty: "medium" },
            "2-13": { name: "Mangrove Myst√©rieuse", hint: "Entre les racines...", groundColor: 0x5d4037, skyColor: 0x8d6e63, fogColor: 0x8d6e63, fogDensity: 0.05, buttonPos: { x: 42, y: 0.5, z: 22 }, levelType: "mangrove", difficulty: "medium" },
            "2-14": { name: "Steppe Vent√©e", hint: "Dans les herbes hautes...", groundColor: 0xc5b358, skyColor: 0xd7ccc8, fogColor: 0xd7ccc8, fogDensity: 0.02, buttonPos: { x: -40, y: 0.5, z: 35 }, levelType: "steppe", difficulty: "medium" },
            "2-15": { name: "For√™t de Pins", hint: "Entre les grands pins...", groundColor: 0x4e342e, skyColor: 0x90a4ae, fogColor: 0x90a4ae, fogDensity: 0.025, buttonPos: { x: 45, y: 0.5, z: -35 }, levelType: "pineforest", difficulty: "medium" },
            "2-16": { name: "Rivage Orageux", hint: "Parmi les rochers...", groundColor: 0x607d8b, skyColor: 0x455a64, fogColor: 0x455a64, fogDensity: 0.035, buttonPos: { x: -42, y: 0.5, z: -28 }, levelType: "stormyshore", difficulty: "medium" },
            "2-17": { name: "D√©sert Glac√©", hint: "Entre les blocs de glace...", groundColor: 0xe0e0e0, skyColor: 0xb0bec5, fogColor: 0xb0bec5, fogDensity: 0.03, buttonPos: { x: 38, y: 0.5, z: 40 }, levelType: "icedesert", difficulty: "medium" },
            "2-18": { name: "Bayou Sinistre", hint: "Dans les eaux troubles...", groundColor: 0x3e2723, skyColor: 0x5d4037, fogColor: 0x5d4037, fogDensity: 0.055, buttonPos: { x: -45, y: 0.5, z: 18 }, levelType: "bayou", difficulty: "medium" },
            "2-19": { name: "For√™t P√©trifi√©e", hint: "Parmi les arbres de pierre...", groundColor: 0x757575, skyColor: 0x9e9e9e, fogColor: 0x9e9e9e, fogDensity: 0.03, buttonPos: { x: 42, y: 0.5, z: -42 }, levelType: "petrified", difficulty: "medium" },
            "2-20": { name: "Terres D√©sol√©es", hint: "Au milieu de nulle part...", groundColor: 0x6d4c41, skyColor: 0x8d6e63, fogColor: 0x8d6e63, fogDensity: 0.04, buttonPos: { x: -48, y: 0.5, z: -40 }, levelType: "wasteland", difficulty: "medium" },

            // CHAPITRE 3: Royaumes Anciens (Difficile) - 20 niveaux
            // difficulty: 'hard' = bouton √† moiti√© cach√© par un objet
            "3-1": { name: "Village Abandonn√©", hint: "Cherche bien...", groundColor: 0x8b7355, skyColor: 0xdeb887, fogColor: 0xdeb887, fogDensity: 0.025, buttonPos: { x: -38, y: 0.5, z: 28 }, levelType: "village", difficulty: "hard" },
            "3-2": { name: "Ruines Antiques", hint: "Derri√®re un pilier...", groundColor: 0x4a4a4a, skyColor: 0x483d8b, fogColor: 0x483d8b, fogDensity: 0.03, buttonPos: { x: 42, y: 0.5, z: -35 }, levelType: "ruins", difficulty: "hard" },
            "3-3": { name: "Temple Ancien", hint: "Pr√®s des colonnes...", groundColor: 0x8d6e63, skyColor: 0x607d8b, fogColor: 0x607d8b, fogDensity: 0.025, buttonPos: { x: -45, y: 0.5, z: -38 }, levelType: "temple", difficulty: "hard" },
            "3-4": { name: "Ville Fant√¥me", hint: "Parmi les d√©combres...", groundColor: 0x5d5d5d, skyColor: 0x34495e, fogColor: 0x34495e, fogDensity: 0.03, buttonPos: { x: 40, y: 0.5, z: 40 }, levelType: "ghosttown", difficulty: "hard" },
            "3-5": { name: "Ch√¢teau en Ruines", hint: "Dans les d√©combres royaux...", groundColor: 0x616161, skyColor: 0x78909c, fogColor: 0x78909c, fogDensity: 0.028, buttonPos: { x: -42, y: 0.5, z: 18 }, levelType: "castleruins", difficulty: "hard" },
            "3-6": { name: "Cit√© Perdue", hint: "Parmi les ruines...", groundColor: 0x455a64, skyColor: 0x607d8b, fogColor: 0x607d8b, fogDensity: 0.035, buttonPos: { x: 38, y: 0.5, z: -42 }, levelType: "lostcity", difficulty: "hard" },
            "3-7": { name: "Monast√®re Ancien", hint: "Dans le silence sacr√©...", groundColor: 0x795548, skyColor: 0xa1887f, fogColor: 0xa1887f, fogDensity: 0.02, buttonPos: { x: -35, y: 0.5, z: -45 }, levelType: "monastery", difficulty: "hard" },
            "3-8": { name: "Palais Effondr√©", hint: "Sous les colonnes...", groundColor: 0xbcaaa4, skyColor: 0xd7ccc8, fogColor: 0xd7ccc8, fogDensity: 0.022, buttonPos: { x: 45, y: 0.5, z: 35 }, levelType: "palace", difficulty: "hard" },
            "3-9": { name: "Tour Abandonn√©e", hint: "Au pied de la tour...", groundColor: 0x546e7a, skyColor: 0x90a4ae, fogColor: 0x90a4ae, fogDensity: 0.025, buttonPos: { x: -48, y: 0.5, z: -22 }, levelType: "tower", difficulty: "hard" },
            "3-10": { name: "Forteresse D√©truite", hint: "Parmi les murs √©croul√©s...", groundColor: 0x37474f, skyColor: 0x546e7a, fogColor: 0x546e7a, fogDensity: 0.032, buttonPos: { x: 35, y: 0.5, z: 48 }, levelType: "fortress", difficulty: "hard" },
            "3-11": { name: "Colis√©e Romain", hint: "Dans l'ar√®ne...", groundColor: 0xd4b896, skyColor: 0xe3d5b8, fogColor: 0xe3d5b8, fogDensity: 0.018, buttonPos: { x: -40, y: 0.5, z: 42 }, levelType: "coliseum", difficulty: "hard" },
            "3-12": { name: "Pyramide Maya", hint: "Pr√®s des pierres...", groundColor: 0x8d6e63, skyColor: 0xa1887f, fogColor: 0xa1887f, fogDensity: 0.02, buttonPos: { x: 48, y: 0.5, z: -28 }, levelType: "pyramid", difficulty: "hard" },
            "3-13": { name: "Cath√©drale Gothique", hint: "Sous les arcs...", groundColor: 0x424242, skyColor: 0x616161, fogColor: 0x616161, fogDensity: 0.035, buttonPos: { x: -45, y: 0.5, z: -48 }, levelType: "cathedral", difficulty: "hard" },
            "3-14": { name: "Citadelle M√©di√©vale", hint: "Derri√®re les remparts...", groundColor: 0x5d4037, skyColor: 0x795548, fogColor: 0x795548, fogDensity: 0.028, buttonPos: { x: 42, y: 0.5, z: 45 }, levelType: "citadel", difficulty: "hard" },
            "3-15": { name: "Amphith√©√¢tre Grec", hint: "Sur les gradins...", groundColor: 0xefebe9, skyColor: 0x90caf9, fogColor: 0x90caf9, fogDensity: 0.015, buttonPos: { x: -50, y: 0.5, z: 15 }, levelType: "amphitheater", difficulty: "hard" },
            "3-16": { name: "Pagode Asiatique", hint: "Pr√®s des lanternes...", groundColor: 0x4e342e, skyColor: 0xffab91, fogColor: 0xffab91, fogDensity: 0.022, buttonPos: { x: 38, y: 0.5, z: -50 }, levelType: "pagoda", difficulty: "hard" },
            "3-17": { name: "Ziggourat Babylonienne", hint: "Sur les terrasses...", groundColor: 0xbcaaa4, skyColor: 0xffe0b2, fogColor: 0xffe0b2, fogDensity: 0.02, buttonPos: { x: -48, y: 0.5, z: 38 }, levelType: "ziggurat", difficulty: "hard" },
            "3-18": { name: "Temple Azt√®que", hint: "Au c≈ìur du temple...", groundColor: 0x6d4c41, skyColor: 0xff8a65, fogColor: 0xff8a65, fogDensity: 0.025, buttonPos: { x: 50, y: 0.5, z: 20 }, levelType: "aztec", difficulty: "hard" },
            "3-19": { name: "Biblioth√®que Perdue", hint: "Parmi les livres...", groundColor: 0x3e2723, skyColor: 0x5d4037, fogColor: 0x5d4037, fogDensity: 0.04, buttonPos: { x: -38, y: 0.5, z: -50 }, levelType: "library", difficulty: "hard" },
            "3-20": { name: "Tr√¥ne Oubli√©", hint: "Devant le tr√¥ne...", groundColor: 0x212121, skyColor: 0x424242, fogColor: 0x424242, fogDensity: 0.035, buttonPos: { x: 48, y: 0.5, z: -48 }, levelType: "throne", difficulty: "hard" },

            // CHAPITRE 4: Mondes Hostiles (Tr√®s Difficile) - 20 niveaux
            // difficulty: 'very_hard' = bouton √† moiti√© cach√© + objets distracteurs
            "4-1": { name: "Grotte Souterraine", hint: "Cherche dans l'obscurit√©...", groundColor: 0x1a1a1a, skyColor: 0x0d0d0d, fogColor: 0x0d0d0d, fogDensity: 0.05, buttonPos: { x: -38, y: 0.5, z: 35 }, levelType: "cave", difficulty: "very_hard" },
            "4-2": { name: "Volcan Actif", hint: "Pr√®s des roches...", groundColor: 0x4a2c2a, skyColor: 0xd32f2f, fogColor: 0xd32f2f, fogDensity: 0.03, buttonPos: { x: 40, y: 0.5, z: -38 }, levelType: "volcano", difficulty: "very_hard" },
            "4-3": { name: "Caverne de Cristaux", hint: "Parmi les cristaux...", groundColor: 0x1a1a2e, skyColor: 0x0f0f1a, fogColor: 0x0f0f1a, fogDensity: 0.025, buttonPos: { x: -42, y: 0.5, z: -32 }, levelType: "crystal", difficulty: "very_hard" },
            "4-4": { name: "Dimension Sombre", hint: "Dans les t√©n√®bres...", groundColor: 0x0a0a0a, skyColor: 0x000000, fogColor: 0x0a0a0a, fogDensity: 0.06, buttonPos: { x: 38, y: 0.5, z: 40 }, levelType: "dark", difficulty: "very_hard" },
            "4-5": { name: "Ab√Æme Glacial", hint: "Dans le froid...", groundColor: 0xb3e5fc, skyColor: 0xe1f5fe, fogColor: 0xe1f5fe, fogDensity: 0.04, buttonPos: { x: -40, y: 0.5, z: 28 }, levelType: "icyabyss", difficulty: "very_hard" },
            "4-6": { name: "Terre de Lave", hint: "Sur les roches br√ªlantes...", groundColor: 0x5d0000, skyColor: 0xff5722, fogColor: 0xff5722, fogDensity: 0.035, buttonPos: { x: 42, y: 0.5, z: -30 }, levelType: "lavaland", difficulty: "very_hard" },
            "4-7": { name: "Caverne Toxique", hint: "Parmi les vapeurs...", groundColor: 0x1b5e20, skyColor: 0x33691e, fogColor: 0x33691e, fogDensity: 0.055, buttonPos: { x: -35, y: 0.5, z: -42 }, levelType: "toxic", difficulty: "very_hard" },
            "4-8": { name: "Void Cosmique", hint: "Dans le vide...", groundColor: 0x0d0d0d, skyColor: 0x000000, fogColor: 0x0d0d0d, fogDensity: 0.02, buttonPos: { x: 40, y: 0.5, z: 35 }, levelType: "void", difficulty: "very_hard" },
            "4-9": { name: "Enfer Gel√©", hint: "Le paradoxe...", groundColor: 0x263238, skyColor: 0x37474f, fogColor: 0x37474f, fogDensity: 0.045, buttonPos: { x: -42, y: 0.5, z: 38 }, levelType: "frozenhell", difficulty: "very_hard" },
            "4-10": { name: "Pic Vertigineux", hint: "Au sommet...", groundColor: 0x78909c, skyColor: 0xeceff1, fogColor: 0xeceff1, fogDensity: 0.03, buttonPos: { x: 38, y: 0.5, z: -42 }, levelType: "peak", difficulty: "very_hard" },
            "4-11": { name: "Gouffre Sans Fin", hint: "Au bord du n√©ant...", groundColor: 0x212121, skyColor: 0x0a0a0a, fogColor: 0x0a0a0a, fogDensity: 0.05, buttonPos: { x: -40, y: 0.5, z: -40 }, levelType: "abyss", difficulty: "very_hard" },
            "4-12": { name: "Terres Corrompues", hint: "Dans la corruption...", groundColor: 0x4a148c, skyColor: 0x6a1b9a, fogColor: 0x6a1b9a, fogDensity: 0.04, buttonPos: { x: 42, y: 0.5, z: 28 }, levelType: "corrupted", difficulty: "very_hard" },
            "4-13": { name: "Glacier Mortel", hint: "Sur la glace...", groundColor: 0xe3f2fd, skyColor: 0xbbdefb, fogColor: 0xbbdefb, fogDensity: 0.035, buttonPos: { x: -38, y: 0.5, z: 42 }, levelType: "glacier", difficulty: "very_hard" },
            "4-14": { name: "Crat√®re Lunaire", hint: "Sur la surface morte...", groundColor: 0x9e9e9e, skyColor: 0x000000, fogColor: 0x212121, fogDensity: 0.015, buttonPos: { x: 42, y: 0.5, z: -40 }, levelType: "lunar", difficulty: "very_hard" },
            "4-15": { name: "Temp√™te de Feu", hint: "Dans les flammes...", groundColor: 0xbf360c, skyColor: 0xff6f00, fogColor: 0xff6f00, fogDensity: 0.045, buttonPos: { x: -42, y: 0.5, z: -38 }, levelType: "firestorm", difficulty: "very_hard" },
            "4-16": { name: "Abysse Oc√©anique", hint: "Dans les profondeurs...", groundColor: 0x0d47a1, skyColor: 0x1565c0, fogColor: 0x1565c0, fogDensity: 0.055, buttonPos: { x: 40, y: 0.5, z: 42 }, levelType: "oceanabyss", difficulty: "very_hard" },
            "4-17": { name: "N√©ant √âternel", hint: "L√† o√π rien n'existe...", groundColor: 0x0a0a0a, skyColor: 0x050505, fogColor: 0x050505, fogDensity: 0.07, buttonPos: { x: -40, y: 0.5, z: 30 }, levelType: "nothingness", difficulty: "very_hard" },
            "4-18": { name: "Monde Invers√©", hint: "Tout est √† l'envers...", groundColor: 0x880e4f, skyColor: 0xad1457, fogColor: 0xad1457, fogDensity: 0.03, buttonPos: { x: -42, y: 0.5, z: -42 }, levelType: "inverted", difficulty: "very_hard" },
            "4-19": { name: "Fracture Dimensionnelle", hint: "Entre les dimensions...", groundColor: 0x311b92, skyColor: 0x4527a0, fogColor: 0x4527a0, fogDensity: 0.04, buttonPos: { x: 42, y: 0.5, z: -42 }, levelType: "fracture", difficulty: "very_hard" },
            "4-20": { name: "Chaos Primordial", hint: "Au c≈ìur du chaos...", groundColor: 0x1a0a0a, skyColor: 0x0a0505, fogColor: 0x0a0505, fogDensity: 0.05, buttonPos: { x: -42, y: 0.5, z: 42 }, levelType: "chaos", difficulty: "very_hard" },

            // CHAPITRE 5: √ânigmes Mystiques (Expert - Puzzles Interactifs) - 20 niveaux
            "5-1": { name: "Cl√© et Porte", hint: "Trouve la cl√© cach√©e... üîë", groundColor: 0x1a1a2e, skyColor: 0x1a0a2e, fogColor: 0x1a0a2e, fogDensity: 0.02, buttonPos: { x: 35, y: 0.5, z: -35 }, special: true, puzzleType: "keyDoor" },
            "5-2": { name: "Trois Interrupteurs", hint: "Active les 3 interrupteurs dans l'ordre... üîå", groundColor: 0x2e1a1a, skyColor: 0x1a1a1a, fogColor: 0x1a1a1a, fogDensity: 0.025, buttonPos: { x: -30, y: 0.5, z: 30 }, special: true, puzzleType: "switches" },
            "5-3": { name: "Levier Cach√©", hint: "Un levier se cache derri√®re les rochers... ‚öôÔ∏è", groundColor: 0x3e2723, skyColor: 0x4e342e, fogColor: 0x4e342e, fogDensity: 0.03, buttonPos: { x: 40, y: 0.5, z: 20 }, special: true, puzzleType: "lever" },
            "5-4": { name: "Collection de Gemmes", hint: "Collecte les 3 gemmes... üíé", groundColor: 0x1a237e, skyColor: 0x283593, fogColor: 0x283593, fogDensity: 0.022, buttonPos: { x: -35, y: 0.5, z: -40 }, special: true, puzzleType: "gems" },
            "5-5": { name: "Rocher Mobile", hint: "Pousse le rocher pour r√©v√©ler... ü™®", groundColor: 0x5d4037, skyColor: 0x6d4c41, fogColor: 0x6d4c41, fogDensity: 0.028, buttonPos: { x: 25, y: 0.5, z: -45 }, special: true, puzzleType: "pushRock" },
            "5-6": { name: "Torches Sacr√©es", hint: "Allume les 3 torches... üî•", groundColor: 0x4a148c, skyColor: 0x6a1b9a, fogColor: 0x6a1b9a, fogDensity: 0.035, buttonPos: { x: -45, y: 0.5, z: 15 }, special: true, puzzleType: "torches" },
            "5-7": { name: "Plaques de Pression", hint: "Marche sur les plaques dans l'ordre... ‚¨õ", groundColor: 0x37474f, skyColor: 0x455a64, fogColor: 0x455a64, fogDensity: 0.025, buttonPos: { x: 35, y: 0.5, z: 40 }, special: true, puzzleType: "plates" },
            "5-8": { name: "Code Secret", hint: "Trouve le code sur les murs... üî¢", groundColor: 0x263238, skyColor: 0x37474f, fogColor: 0x37474f, fogDensity: 0.03, buttonPos: { x: -40, y: 0.5, z: -30 }, special: true, puzzleType: "code" },
            "5-9": { name: "Double Serrure", hint: "Trouve les 2 cl√©s pour les 2 portes... üîê", groundColor: 0x1a1a2e, skyColor: 0x0d0d1a, fogColor: 0x0d0d1a, fogDensity: 0.025, buttonPos: { x: 45, y: 0.5, z: -15 }, special: true, puzzleType: "doubleKey" },
            "5-10": { name: "Cristaux Color√©s", hint: "Active les cristaux dans l'ordre des couleurs... üåà", groundColor: 0x311b92, skyColor: 0x4527a0, fogColor: 0x4527a0, fogDensity: 0.02, buttonPos: { x: -25, y: 0.5, z: 45 }, special: true, puzzleType: "colorCrystals" },
            "5-11": { name: "Carte au Tr√©sor", hint: "Trouve le fragment de carte... üó∫Ô∏è", groundColor: 0x795548, skyColor: 0x8d6e63, fogColor: 0x8d6e63, fogDensity: 0.028, buttonPos: { x: 50, y: 0.5, z: 30 }, special: true, puzzleType: "treasureMap" },
            "5-12": { name: "Lib√©rer les Eaux", hint: "Ouvre la vanne pour r√©v√©ler... üíß", groundColor: 0x01579b, skyColor: 0x0277bd, fogColor: 0x0277bd, fogDensity: 0.03, buttonPos: { x: -50, y: 0.5, z: -20 }, special: true, puzzleType: "water" },
            "5-13": { name: "Mur Fragile", hint: "Un mur semble fragile... üß±", groundColor: 0x4e342e, skyColor: 0x5d4037, fogColor: 0x5d4037, fogDensity: 0.032, buttonPos: { x: 30, y: 0.5, z: -50 }, special: true, puzzleType: "breakWall" },
            "5-14": { name: "Runes Anciennes", hint: "Collecte les 4 runes... ·ö±·ö¢·öæ·õñ", groundColor: 0x3e2723, skyColor: 0x4e342e, fogColor: 0x4e342e, fogDensity: 0.035, buttonPos: { x: -35, y: 0.5, z: 50 }, special: true, puzzleType: "runes" },
            "5-15": { name: "Piliers Rotatifs", hint: "Aligne les symboles des piliers... üîÑ", groundColor: 0x455a64, skyColor: 0x546e7a, fogColor: 0x546e7a, fogDensity: 0.025, buttonPos: { x: 48, y: 0.5, z: 48 }, special: true, puzzleType: "pillars" },
            "5-16": { name: "Fant√¥me Guide", hint: "Suis le fant√¥me... üëª", groundColor: 0x1a1a1a, skyColor: 0x212121, fogColor: 0x212121, fogDensity: 0.045, buttonPos: { x: -48, y: 0.5, z: 40 }, special: true, puzzleType: "ghost" },
            "5-17": { name: "Graine Magique", hint: "Plante et arrose la graine... üå±", groundColor: 0x33691e, skyColor: 0x558b2f, fogColor: 0x558b2f, fogDensity: 0.02, buttonPos: { x: 40, y: 0.5, z: -48 }, special: true, puzzleType: "seed" },
            "5-18": { name: "Labyrinthe Int√©rieur", hint: "Trouve la sortie du labyrinthe... üåÄ", groundColor: 0x424242, skyColor: 0x616161, fogColor: 0x616161, fogDensity: 0.04, buttonPos: { x: -30, y: 0.5, z: -50 }, special: true, puzzleType: "maze" },
            "5-19": { name: "√ânigme des √âtoiles", hint: "Aligne les constellations... ‚≠ê", groundColor: 0x0d0d1a, skyColor: 0x000005, fogColor: 0x0d0d1a, fogDensity: 0.015, buttonPos: { x: 50, y: 0.5, z: -40 }, special: true, puzzleType: "stars" },
            "5-20": { name: "√âpreuve Ultime", hint: "Combine tous tes savoirs... üëë", groundColor: 0x1a0a1a, skyColor: 0x0a050a, fogColor: 0x0a050a, fogDensity: 0.025, buttonPos: { x: 0, y: 0.5, z: 0 }, special: true, puzzleType: "ultimate" }
        };

        // Helper function to get level key
        function getLevelKey(chapter, level) {
            return `${chapter}-${level}`;
        }

        // Get current level config
        function getCurrentLevelConfig() {
            return levelConfigs[getLevelKey(currentChapter, currentLevel)];
        }

        // Initialize Three.js
        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, cameraHeight, cameraDistance);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // Create player
            createPlayer();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('contextmenu', (e) => e.preventDefault()); // D√©sactiver menu contextuel
            window.addEventListener('wheel', onMouseWheel); // Zoom avec molette

            // UI Event listeners
            document.getElementById('cameraBtn').addEventListener('click', changeCamera);
            document.getElementById('menuBtn').addEventListener('click', backToMenu);
            document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);
            document.getElementById('backToMenuBtn').addEventListener('click', backToMenu);

            // Chapter buttons
            document.querySelectorAll('.chapter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedChapter = parseInt(btn.dataset.chapter);
                    showLevelSelect(selectedChapter);
                });
            });

            // Back to chapters button
            document.getElementById('backToChaptersBtn').addEventListener('click', () => {
                document.getElementById('levelSelectScreen').style.display = 'none';
                document.getElementById('menuScreen').style.display = 'flex';
            });

            // Play from level select
            document.getElementById('playLevelBtn').addEventListener('click', () => {
                currentChapter = selectedChapter;
                currentLevel = selectedLevel;
                startGame();
            });

            animate();
        }

        // Show level selection for a chapter
        function showLevelSelect(chapter) {
            // Mettre √† jour selectedChapter quand on affiche un chapitre
            selectedChapter = chapter;

            const chapterData = chapterInfo[chapter];
            document.getElementById('chapterTitle').innerHTML = `${chapterData.icon} ${chapterData.name}`;
            document.getElementById('chapterTitle').style.color = chapterData.color;

            const container = document.getElementById('levelButtonsContainer');
            container.innerHTML = '';

            // Generate 20 level buttons for this chapter
            for (let i = 1; i <= 20; i++) {
                const levelKey = getLevelKey(chapter, i);
                const config = levelConfigs[levelKey];

                const btn = document.createElement('button');
                btn.className = `level-btn chapter${chapter}-level ${i === 1 ? 'selected' : ''}`;
                btn.dataset.level = i;
                btn.innerHTML = `<div>${i}</div><small style="opacity:0.7;font-size:0.6rem;">${config.name.split(' ')[0]}</small>`;
                btn.style.color = chapterData.color;
                btn.style.borderColor = chapterData.color;

                btn.addEventListener('click', () => {
                    // Reset all buttons styles
                    container.querySelectorAll('.level-btn').forEach(b => {
                        b.classList.remove('selected');
                        b.style.background = 'rgba(255, 255, 255, 0.05)';
                        b.style.color = chapterData.color;
                    });
                    // Select clicked button
                    btn.classList.add('selected');
                    btn.style.background = chapterData.color;
                    btn.style.color = '#0a0a0f';
                    selectedLevel = i;
                });

                // Style initial selected state (level 1)
                if (i === 1) {
                    btn.style.background = chapterData.color;
                    btn.style.color = '#0a0a0f';
                    selectedLevel = 1;
                }

                container.appendChild(btn);
            }

            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('levelSelectScreen').style.display = 'flex';
        }

        function createPlayer() {
            player = new THREE.Group();

            // Body (blue shirt)
            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2563eb });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.25;
            body.castShadow = true;
            player.add(body);

            // Head (skin color)
            const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const skinMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 2.4;
            head.castShadow = true;
            player.add(head);

            // Cap (blue)
            const capBaseGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
            const capMaterial = new THREE.MeshLambertMaterial({ color: 0x1d4ed8 });
            const capBase = new THREE.Mesh(capBaseGeometry, capMaterial);
            capBase.position.y = 2.9;
            capBase.castShadow = true;
            player.add(capBase);

            // Cap visor
            const visorGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.4);
            const visor = new THREE.Mesh(visorGeometry, capMaterial);
            visor.position.set(0, 2.85, 0.5);
            visor.castShadow = true;
            player.add(visor);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 2.45, 0.4);
            player.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 2.45, 0.4);
            player.add(rightEye);

            // === BRAS AVEC PIVOT (pour animation) ===
            const armGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);

            // Bras gauche
            leftArmPivot = new THREE.Group();
            leftArmPivot.position.set(-0.65, 1.7, 0); // Position de l'√©paule
            const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
            leftArm.position.y = -0.5; // D√©cal√© vers le bas depuis le pivot
            leftArm.castShadow = true;
            leftArmPivot.add(leftArm);
            player.add(leftArmPivot);

            // Bras droit
            rightArmPivot = new THREE.Group();
            rightArmPivot.position.set(0.65, 1.7, 0); // Position de l'√©paule
            const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
            rightArm.position.y = -0.5;
            rightArm.castShadow = true;
            rightArmPivot.add(rightArm);
            player.add(rightArmPivot);

            // === JAMBES AVEC PIVOT (pour animation) ===
            const legGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x1e40af });
            const shoeGeometry = new THREE.BoxGeometry(0.45, 0.2, 0.5);
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0x1e1e1e });

            // Jambe gauche avec chaussure
            leftLegPivot = new THREE.Group();
            leftLegPivot.position.set(-0.25, 0.8, 0); // Position de la hanche
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.y = -0.5; // D√©cal√© vers le bas depuis le pivot
            leftLeg.castShadow = true;
            leftLegPivot.add(leftLeg);
            // Chaussure gauche attach√©e √† la jambe
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(0, -0.9, 0.05);
            leftShoe.castShadow = true;
            leftLegPivot.add(leftShoe);
            player.add(leftLegPivot);

            // Jambe droite avec chaussure
            rightLegPivot = new THREE.Group();
            rightLegPivot.position.set(0.25, 0.8, 0); // Position de la hanche
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.y = -0.5;
            rightLeg.castShadow = true;
            rightLegPivot.add(rightLeg);
            // Chaussure droite attach√©e √† la jambe
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0, -0.9, 0.05);
            rightShoe.castShadow = true;
            rightLegPivot.add(rightShoe);
            player.add(rightLegPivot);

            player.position.y = 0;
            scene.add(player);
        }

        function updateWalkAnimation() {
            // V√©rifier si le joueur marche
            const isMoving = keys.KeyW || keys.KeyA || keys.KeyS || keys.KeyD;

            if (isMoving && isGrounded) {
                isWalking = true;
                walkAnimationTime += 0.15; // Vitesse de l'animation

                // Balancement des jambes (oppos√©es)
                const legSwing = Math.sin(walkAnimationTime) * 0.6; // Amplitude du balancement
                leftLegPivot.rotation.x = legSwing;
                rightLegPivot.rotation.x = -legSwing;

                // Balancement des bras (oppos√©s aux jambes)
                leftArmPivot.rotation.x = -legSwing * 0.7;
                rightArmPivot.rotation.x = legSwing * 0.7;
            } else {
                isWalking = false;
                // Retour progressif √† la position neutre
                leftLegPivot.rotation.x *= 0.8;
                rightLegPivot.rotation.x *= 0.8;
                leftArmPivot.rotation.x *= 0.8;
                rightArmPivot.rotation.x *= 0.8;
            }
        }

        function createRedButton(x, y, z) {
            const buttonGroup = new THREE.Group();

            // Button base
            const baseGeometry = new THREE.CylinderGeometry(0.8, 1, 0.3, 32);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.15;
            base.castShadow = true;
            base.receiveShadow = true;
            buttonGroup.add(base);

            // Button top (red)
            const topGeometry = new THREE.CylinderGeometry(0.6, 0.7, 0.4, 32);
            const topMaterial = new THREE.MeshLambertMaterial({ color: 0xe94560 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 0.5;
            top.castShadow = true;
            buttonGroup.add(top);

            // Glow ring
            const ringGeometry = new THREE.TorusGeometry(0.75, 0.05, 8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.3;
            buttonGroup.add(ring);

            buttonGroup.position.set(x, y, z);
            scene.add(buttonGroup);

            redButton = buttonGroup;
            redButton.userData.baseY = y;
            return buttonGroup;
        }

        // Fonction pour cr√©er des √Æles distantes sur les bords
        function createDistantIslands(groundColor, skyColor) {
            // Positions des √Æles lointaines (au-del√† des limites jouables)
            const islandPositions = [
                { x: -120, z: -80, scale: 1.2 },
                { x: -150, z: 20, scale: 0.8 },
                { x: -100, z: 100, scale: 1.0 },
                { x: 0, z: 150, scale: 1.5 },
                { x: 80, z: 130, scale: 0.9 },
                { x: 150, z: 50, scale: 1.1 },
                { x: 140, z: -60, scale: 0.7 },
                { x: 100, z: -120, scale: 1.3 },
                { x: -20, z: -140, scale: 1.0 },
                { x: -130, z: -40, scale: 0.6 },
                { x: 160, z: -20, scale: 0.85 },
                { x: -80, z: 140, scale: 0.95 }
            ];

            islandPositions.forEach(pos => {
                const island = new THREE.Group();

                // Base de l'√Æle (terrain)
                const baseGeometry = new THREE.CylinderGeometry(
                    8 * pos.scale,
                    12 * pos.scale,
                    4 * pos.scale,
                    8
                );
                const baseMaterial = new THREE.MeshLambertMaterial({ color: groundColor });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -1 * pos.scale;
                island.add(base);

                // Dessous de l'√Æle (rochers)
                const underGeometry = new THREE.ConeGeometry(10 * pos.scale, 15 * pos.scale, 6);
                const underMaterial = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
                const under = new THREE.Mesh(underGeometry, underMaterial);
                under.position.y = -10 * pos.scale;
                under.rotation.x = Math.PI;
                island.add(under);

                // Arbres/v√©g√©tation sur l'√Æle
                const numTrees = Math.floor(2 + seededRandom() * 4);
                for (let i = 0; i < numTrees; i++) {
                    const tree = new THREE.Group();

                    // Tronc
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3 * pos.scale, 0.5 * pos.scale, 3 * pos.scale, 6),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    trunk.position.y = 1.5 * pos.scale;
                    tree.add(trunk);

                    // Feuillage
                    const leaves = new THREE.Mesh(
                        new THREE.SphereGeometry(2 * pos.scale, 6, 6),
                        new THREE.MeshLambertMaterial({ color: 0x228B22 })
                    );
                    leaves.position.y = 4 * pos.scale;
                    tree.add(leaves);

                    // Position al√©atoire sur l'√Æle
                    const angle = (i / numTrees) * Math.PI * 2 + seededRandom() * 0.5;
                    const dist = 2 + seededRandom() * 4;
                    tree.position.set(
                        Math.cos(angle) * dist * pos.scale,
                        1 * pos.scale,
                        Math.sin(angle) * dist * pos.scale
                    );
                    island.add(tree);
                }

                // Quelques rochers sur l'√Æle
                for (let i = 0; i < 2; i++) {
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(1 * pos.scale),
                        new THREE.MeshLambertMaterial({ color: 0x696969 })
                    );
                    rock.position.set(
                        (seededRandom() - 0.5) * 8 * pos.scale,
                        0.5 * pos.scale,
                        (seededRandom() - 0.5) * 8 * pos.scale
                    );
                    island.add(rock);
                }

                // Petite structure/maison sur certaines √Æles
                if (seededRandom() > 0.6) {
                    const house = new THREE.Mesh(
                        new THREE.BoxGeometry(2 * pos.scale, 2 * pos.scale, 2 * pos.scale),
                        new THREE.MeshLambertMaterial({ color: 0xdeb887 })
                    );
                    house.position.y = 2 * pos.scale;
                    island.add(house);

                    const roof = new THREE.Mesh(
                        new THREE.ConeGeometry(2 * pos.scale, 1.5 * pos.scale, 4),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    roof.position.y = 3.5 * pos.scale;
                    roof.rotation.y = Math.PI / 4;
                    island.add(roof);
                }

                // Position finale de l'√Æle
                island.position.set(pos.x, -5, pos.z);
                scene.add(island);
                levelObjects.push(island);
            });

            // Ajouter un "vide" / abysse en dessous
            const voidGeometry = new THREE.PlaneGeometry(500, 500);
            const voidMaterial = new THREE.MeshBasicMaterial({
                color: 0x1a1a2e,
                transparent: true,
                opacity: 0.8
            });
            const voidPlane = new THREE.Mesh(voidGeometry, voidMaterial);
            voidPlane.rotation.x = -Math.PI / 2;
            voidPlane.position.y = -30;
            scene.add(voidPlane);
            levelObjects.push(voidPlane);
        }

        // Master function to create level by type
        function createLevelByType(levelType) {
            // Chapter 1: Prairies Verdoyantes
            if (levelType === 'garden') createGardenLevel();
            else if (levelType === 'meadow') createMeadowLevel();
            else if (levelType === 'clearing') createClearingLevel();
            else if (levelType === 'butterfly') createButterflyLevel();
            else if (levelType === 'valley') createValleyLevel();
            else if (levelType === 'hills') createHillsLevel();
            else if (levelType === 'secretgarden') createSecretGardenLevel();
            else if (levelType === 'plain') createPlainLevel();
            else if (levelType === 'grove') createGroveLevel();
            else if (levelType === 'flowerfield') createFlowerFieldLevel();
            else if (levelType === 'castlelawn') createCastleLawnLevel();
            else if (levelType === 'pasture') createPastureLevel();
            else if (levelType === 'orchard') createOrchardLevel();
            else if (levelType === 'zen') createZenLevel();
            else if (levelType === 'mistymeadow') createMistyMeadowLevel();
            else if (levelType === 'magicclearing') createMagicClearingLevel();
            else if (levelType === 'fairyvalley') createFairyValleyLevel();
            else if (levelType === 'enchanted') createEnchantedLevel();
            else if (levelType === 'paradise') createParadiseLevel();
            else if (levelType === 'eternal') createEternalLevel();
            // Chapter 2: Terres Sauvages
            else if (levelType === 'forest') createForestLevel();
            else if (levelType === 'beach') createBeachLevel();
            else if (levelType === 'desert') createDesertLevel();
            else if (levelType === 'canyon') createCanyonLevel();
            else if (levelType === 'bamboo') createBambooLevel();
            else if (levelType === 'swamp') createSwampLevel();
            else if (levelType === 'savanna') createSavannaLevel();
            else if (levelType === 'jungle') createJungleLevel();
            else if (levelType === 'coast') createCoastLevel();
            else if (levelType === 'dunes') createDunesLevel();
            else if (levelType === 'amazon') createAmazonLevel();
            else if (levelType === 'oasis') createOasisLevel();
            else if (levelType === 'mangrove') createMangroveLevel();
            else if (levelType === 'steppe') createSteppeLevel();
            else if (levelType === 'pineforest') createPineForestLevel();
            else if (levelType === 'stormyshore') createStormyShoreLevel();
            else if (levelType === 'icedesert') createIceDesertLevel();
            else if (levelType === 'bayou') createBayouLevel();
            else if (levelType === 'petrified') createPetrifiedLevel();
            else if (levelType === 'wasteland') createWastelandLevel();
            // Chapter 3: Royaumes Anciens
            else if (levelType === 'village') createVillageLevel();
            else if (levelType === 'ruins') createRuinsLevel();
            else if (levelType === 'temple') createTempleLevel();
            else if (levelType === 'ghosttown') createGhostTownLevel();
            else if (levelType === 'castleruins') createCastleRuinsLevel();
            else if (levelType === 'lostcity') createLostCityLevel();
            else if (levelType === 'monastery') createMonasteryLevel();
            else if (levelType === 'palace') createPalaceLevel();
            else if (levelType === 'tower') createTowerLevel();
            else if (levelType === 'fortress') createFortressLevel();
            else if (levelType === 'coliseum') createColiseumLevel();
            else if (levelType === 'pyramid') createPyramidLevel();
            else if (levelType === 'cathedral') createCathedralLevel();
            else if (levelType === 'citadel') createCitadelLevel();
            else if (levelType === 'amphitheater') createAmphitheaterLevel();
            else if (levelType === 'pagoda') createPagodaLevel();
            else if (levelType === 'ziggurat') createZigguratLevel();
            else if (levelType === 'aztec') createAztecLevel();
            else if (levelType === 'library') createLibraryLevel();
            else if (levelType === 'throne') createThroneLevel();
            // Chapter 4: Mondes Hostiles
            else if (levelType === 'cave') createCaveLevel();
            else if (levelType === 'volcano') createVolcanoLevel();
            else if (levelType === 'crystal') createCrystalLevel();
            else if (levelType === 'dark') createDarkDimensionLevel();
            else if (levelType === 'icyabyss') createIcyAbyssLevel();
            else if (levelType === 'lavaland') createLavaLandLevel();
            else if (levelType === 'toxic') createToxicLevel();
            else if (levelType === 'void') createVoidLevel();
            else if (levelType === 'frozenhell') createFrozenHellLevel();
            else if (levelType === 'peak') createPeakLevel();
            else if (levelType === 'abyss') createAbyssLevel();
            else if (levelType === 'corrupted') createCorruptedLevel();
            else if (levelType === 'glacier') createGlacierLevel();
            else if (levelType === 'lunar') createLunarLevel();
            else if (levelType === 'firestorm') createFirestormLevel();
            else if (levelType === 'oceanabyss') createOceanAbyssLevel();
            else if (levelType === 'nothingness') createNothingnessLevel();
            else if (levelType === 'inverted') createInvertedLevel();
            else if (levelType === 'fracture') createFractureLevel();
            else if (levelType === 'chaos') createChaosLevel();
            // Chapter 5: √ânigmes Mystiques (Puzzles)
            else if (levelType === 'keyDoor') createKeyDoorPuzzle();
            else if (levelType === 'switches') createSwitchesPuzzle();
            else if (levelType === 'lever') createLeverPuzzle();
            else if (levelType === 'gems') createGemsPuzzle();
            else if (levelType === 'pushRock') createPushRockPuzzle();
            else if (levelType === 'torches') createTorchesPuzzle();
            else if (levelType === 'plates') createPlatesPuzzle();
            else if (levelType === 'code') createCodePuzzle();
            else if (levelType === 'doubleKey') createDoubleKeyPuzzle();
            else if (levelType === 'colorCrystals') createColorCrystalsPuzzle();
            else if (levelType === 'treasureMap') createTreasureMapPuzzle();
            else if (levelType === 'water') createWaterPuzzle();
            else if (levelType === 'breakWall') createBreakWallPuzzle();
            else if (levelType === 'runes') createRunesPuzzle();
            else if (levelType === 'pillars') createPillarsPuzzle();
            else if (levelType === 'ghost') createGhostPuzzle();
            else if (levelType === 'seed') createSeedPuzzle();
            else if (levelType === 'maze') createMazePuzzle();
            else if (levelType === 'stars') createStarsPuzzle();
            else if (levelType === 'ultimate') createUltimatePuzzle();
            // Default fallback
            else createGardenLevel();
        }

        // Fonction pour cacher le bouton selon la difficult√©
        // easy: bouton juste derri√®re UN objet (tr√®s visible)
        // medium: bouton entre des objets mais 100% visible
        // hard: bouton √† moiti√© cach√© par un objet (50% max)
        // very_hard: bouton √† moiti√© cach√©, position plus sournoise
        function createButtonHidingSpot(difficulty, levelType) {
            if (!redButton) return;
            const bx = redButton.position.x;
            const bz = redButton.position.z;

            // Choisir le type d'objet selon le th√®me
            const themeObjects = {
                // Nature
                'garden': 'bush', 'meadow': 'grass', 'clearing': 'tree', 'butterfly': 'flower',
                'valley': 'bush', 'hills': 'rock', 'secretgarden': 'bush', 'plain': 'bush',
                'grove': 'bush', 'flowerfield': 'flower', 'castlelawn': 'bush', 'pasture': 'bush',
                'orchard': 'tree', 'zen': 'rock', 'mistymeadow': 'bush', 'magicclearing': 'tree',
                'fairyvalley': 'tree', 'enchanted': 'tree', 'paradise': 'bush', 'eternal': 'bush',
                // Sauvage
                'forest': 'tree', 'beach': 'palm', 'desert': 'cactus', 'canyon': 'rock',
                'bamboo': 'bamboo', 'swamp': 'bush', 'savanna': 'tree', 'jungle': 'tree',
                'coast': 'rock', 'dunes': 'cactus', 'amazon': 'tree', 'oasis': 'palm',
                'mangrove': 'tree', 'steppe': 'grass', 'pineforest': 'tree', 'stormyshore': 'rock',
                'icedesert': 'rock', 'bayou': 'tree', 'petrified': 'rock', 'wasteland': 'rock',
                // Ruines
                'village': 'rock', 'ruins': 'pillar', 'temple': 'pillar', 'ghosttown': 'rock',
                'castleruins': 'rock', 'lostcity': 'pillar', 'monastery': 'pillar', 'palace': 'pillar',
                'tower': 'rock', 'fortress': 'rock', 'coliseum': 'pillar', 'pyramid': 'rock',
                'cathedral': 'pillar', 'citadel': 'rock', 'amphitheater': 'pillar', 'pagoda': 'pillar',
                'ziggurat': 'rock', 'aztec': 'rock', 'library': 'pillar', 'throne': 'pillar',
                // Hostile
                'cave': 'rock', 'volcano': 'rock', 'crystal': 'crystal', 'dark': 'rock',
                'icyabyss': 'ice', 'lavaland': 'rock', 'toxic': 'rock', 'void': 'rock',
                'frozenhell': 'ice', 'peak': 'rock', 'abyss': 'rock', 'corrupted': 'crystal',
                'glacier': 'ice', 'lunar': 'rock', 'firestorm': 'rock', 'oceanabyss': 'rock',
                'nothingness': 'rock', 'inverted': 'rock', 'fracture': 'crystal', 'chaos': 'rock'
            };

            const objType = themeObjects[levelType] || 'bush';

            // Couleurs sp√©cifiques par niveau pour correspondre aux objets existants
            const themeColors = {
                // Rochers
                'hills': 0x9e9e9e, 'zen': 0x505050, 'canyon': 0xcd853f, 'coast': 0x607d8b,
                'stormyshore': 0x607d8b, 'icedesert': 0xcfd8dc, 'petrified': 0x757575,
                'wasteland': 0x6d4c41, 'village': 0x8b7355, 'ghosttown': 0x5d5d5d,
                'castleruins': 0x616161, 'tower': 0x546e7a, 'fortress': 0x37474f,
                'citadel': 0x5d4037, 'cave': 0x3e2723, 'volcano': 0x37474f,
                'dark': 0x1a1a1a, 'lavaland': 0x37474f, 'toxic': 0x33691e,
                'void': 0x0d0d0d, 'frozenhell': 0x263238, 'peak': 0x78909c,
                'abyss': 0x212121, 'lunar': 0x9e9e9e, 'firestorm': 0xbf360c, 'oceanabyss': 0x0d47a1,
                'nothingness': 0x0a0a0a, 'inverted': 0x880e4f, 'chaos': 0x1a0a0a,
                'pyramid': 0x8d6e63, 'ziggurat': 0xbcaaa4, 'aztec': 0x6d4c41,
                // Buissons
                'garden': 0x2ecc71, 'meadow': 0x2ecc71, 'valley': 0x2e7d32, 'secretgarden': 0x2e7d32,
                'plain': 0x2ecc71, 'grove': 0x2ecc71, 'castlelawn': 0x228b22, 'pasture': 0x2ecc71,
                'mistymeadow': 0x558b2f, 'swamp': 0x4a5d23, 'paradise': 0x2ecc71, 'eternal': 0x2ecc71,
                // Piliers
                'ruins': 0x808080, 'temple': 0xa1887f, 'lostcity': 0x455a64, 'monastery': 0x795548,
                'palace': 0xbcaaa4, 'coliseum': 0xd4b896, 'cathedral': 0x424242,
                'amphitheater': 0xefebe9, 'pagoda': 0x4e342e, 'library': 0x3e2723, 'throne': 0x212121,
                // Cristaux (couleurs vari√©es des niveaux cristallins)
                'crystal': 0x9b59b6, 'corrupted': 0x9b59b6, 'fracture': 0x9b59b6,
                // Glace
                'icyabyss': 0xb3e5fc, 'glacier': 0xb3e5fc
            };

            const objColor = themeColors[levelType] || 0x696969;

            // Fonction pour cr√©er un objet cachant
            function createHidingObject(x, z, scale = 1) {
                let obj;
                if (objType === 'bush') {
                    const r = 1.2 * scale;
                    obj = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 8), new THREE.MeshLambertMaterial({ color: objColor }));
                    obj.position.set(x, r * 0.6, z);
                    addSolidObject(x, z, r, r * 1.6); // Hauteur = position Y + rayon
                } else if (objType === 'rock') {
                    const r = 1.5 * scale;
                    obj = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: objColor }));
                    obj.position.set(x, r * 0.5, z);
                    obj.rotation.set(seededRandom(), seededRandom(), seededRandom());
                    addSolidObject(x, z, r, r * 1.5);
                } else if (objType === 'tree') {
                    createTree(x, z, 0.8 * scale);
                    return null; // createTree ajoute d√©j√† √† levelObjects
                } else if (objType === 'palm') {
                    createPalm(x, z);
                    return null;
                } else if (objType === 'cactus') {
                    createCactus(x, z);
                    return null;
                } else if (objType === 'pillar') {
                    const h = 3 * scale;
                    obj = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, h, 8), new THREE.MeshLambertMaterial({ color: objColor }));
                    obj.position.set(x, h / 2, z);
                    addSolidObject(x, z, 0.6, h);
                } else if (objType === 'crystal') {
                    const h = 2 * scale;
                    // Les cristaux utilisent la couleur du th√®me avec effet √©missif
                    obj = new THREE.Mesh(new THREE.ConeGeometry(0.5, h, 6), new THREE.MeshLambertMaterial({ color: objColor, emissive: objColor, emissiveIntensity: 0.2 }));
                    obj.position.set(x, h / 2, z);
                    addSolidObject(x, z, 0.5, h);
                } else if (objType === 'ice') {
                    const r = 1.2 * scale;
                    obj = new THREE.Mesh(new THREE.BoxGeometry(r, r * 1.5, r), new THREE.MeshLambertMaterial({ color: objColor, transparent: true, opacity: 0.8 }));
                    obj.position.set(x, r * 0.75, z);
                    addSolidObject(x, z, r * 0.7, r * 1.5);
                } else if (objType === 'flower') {
                    const r = 0.8 * scale;
                    obj = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 8), new THREE.MeshLambertMaterial({ color: 0xff69b4 }));
                    obj.position.set(x, r * 0.5, z);
                } else if (objType === 'grass') {
                    // Grosse touffe d'herbe haute pour cacher le bouton
                    // Couleurs qui correspondent au niveau Prairie
                    const grassColors = [0x7dcea0, 0x98d9a0, 0x5daa7a];
                    const group = new THREE.Group();
                    for (let i = 0; i < 30; i++) {
                        const h = 2 + seededRandom() * 1.5 * scale;
                        const colorIndex = Math.floor(seededRandom() * grassColors.length);
                        const blade = new THREE.Mesh(new THREE.ConeGeometry(0.15, h, 4), new THREE.MeshLambertMaterial({ color: grassColors[colorIndex] }));
                        blade.position.set((seededRandom() - 0.5) * 2.5, h / 2, (seededRandom() - 0.5) * 2.5);
                        blade.rotation.set((seededRandom() - 0.5) * 0.3, 0, (seededRandom() - 0.5) * 0.3);
                        group.add(blade);
                    }
                    group.position.set(x, 0, z);
                    scene.add(group); levelObjects.push(group);
                    return null;
                } else {
                    // D√©faut: buisson
                    const r = 1 * scale;
                    obj = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 8), new THREE.MeshLambertMaterial({ color: 0x388e3c }));
                    obj.position.set(x, r * 0.5, z);
                    addSolidObject(x, z, r, r * 1.5); // Hauteur corrig√©e
                }
                if (obj) { scene.add(obj); levelObjects.push(obj); }
                return obj;
            }

            if (difficulty === 'easy') {
                // Plusieurs objets autour du bouton pour le cacher
                if (objType === 'grass') {
                    // Plusieurs touffes d'herbe autour du bouton
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const dist = 1.2;
                        createHidingObject(bx + Math.cos(angle) * dist, bz + Math.sin(angle) * dist, 1);
                    }
                } else if (objType === 'tree') {
                    // Plusieurs arbres autour du bouton pour le cacher entre eux
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + seededRandom() * 0.3;
                        const dist = 3 + seededRandom() * 1;
                        createHidingObject(bx + Math.cos(angle) * dist, bz + Math.sin(angle) * dist, 0.8);
                    }
                } else if (objType === 'flower') {
                    // Beaucoup de fleurs autour du bouton
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + seededRandom() * 0.3;
                        const dist = 1 + seededRandom() * 0.5;
                        createHidingObject(bx + Math.cos(angle) * dist, bz + Math.sin(angle) * dist, 1.2);
                    }
                } else if (objType === 'bush') {
                    // Plusieurs buissons autour du bouton
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + seededRandom() * 0.3;
                        const dist = 1.5 + seededRandom() * 0.5;
                        createHidingObject(bx + Math.cos(angle) * dist, bz + Math.sin(angle) * dist, 1);
                    }
                } else if (objType === 'rock') {
                    // Plusieurs rochers autour du bouton
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + seededRandom() * 0.4;
                        const dist = 1.8 + seededRandom() * 0.5;
                        createHidingObject(bx + Math.cos(angle) * dist, bz + Math.sin(angle) * dist, 1.1);
                    }
                } else {
                    // D√©faut: plusieurs objets autour
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2 + seededRandom() * 0.3;
                        const dist = 2;
                        createHidingObject(bx + Math.cos(angle) * dist, bz + Math.sin(angle) * dist, 1);
                    }
                }
            }
            else if (difficulty === 'medium') {
                // Plusieurs objets AUTOUR du bouton mais pas dessus (100% visible)
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2 + seededRandom() * 0.5;
                    const dist = 2.5 + seededRandom() * 0.5;
                    createHidingObject(bx + Math.cos(angle) * dist, bz + Math.sin(angle) * dist, 0.9);
                }
            }
            else if (difficulty === 'hard') {
                // UN objet qui cache PARTIELLEMENT le bouton (√† moiti√©)
                const angle = seededRandom() * Math.PI * 2;
                const dist = 1.2; // Plus proche = partiellement cach√©
                createHidingObject(bx + Math.cos(angle) * dist, bz + Math.sin(angle) * dist, 1.2);
            }
            else if (difficulty === 'very_hard') {
                // Objet qui cache le bouton √† moiti√© + objets distracteurs proches
                const angle = seededRandom() * Math.PI * 2;
                createHidingObject(bx + Math.cos(angle) * 1.0, bz + Math.sin(angle) * 1.0, 1.3);
                // Objets distracteurs
                for (let i = 0; i < 2; i++) {
                    const a2 = angle + Math.PI * (0.6 + seededRandom() * 0.8);
                    createHidingObject(bx + Math.cos(a2) * 3, bz + Math.sin(a2) * 3, 1);
                }
            }
        }

        // Fonction pour cr√©er des faux groupements d'objets TH√âMATIQUES (pour tromper le joueur)
        function createFakeHidingSpots(levelType) {
            const numFakeSpots = 10 + Math.floor(seededRandom() * 6); // 10-15 spots

            // Obtenir la position du bouton
            const buttonX = redButton ? redButton.position.x : 0;
            const buttonZ = redButton ? redButton.position.z : 0;

            // Positions al√©atoires (√©viter le centre, le bouton est d√©j√† cach√©)
            const positions = [];
            for (let i = 0; i < numFakeSpots; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 80;
                    z = (seededRandom() - 0.5) * 80;
                    attempts++;
                    const distToButton = Math.sqrt((x - buttonX) ** 2 + (z - buttonZ) ** 2);
                    const distToSpawn = Math.sqrt(x * x + z * z);
                    // √âviter le spawn (rayon 15) ET √©viter d'√™tre trop proche du bouton (rayon 12)
                    if (distToSpawn > 15 && distToButton > 12) break;
                } while (attempts < 50);
                positions.push({ x, z });
            }

            positions.forEach(pos => {
                // Map level types to cluster creators
                const clusterMap = {
                    // Chapter 1: Nature themes
                    'garden': createFlowerBushCluster,
                    'meadow': createFlowerBushCluster,
                    'clearing': createForestCluster,
                    'butterfly': createFlowerBushCluster,
                    'valley': createFlowerBushCluster,
                    'hills': createFlowerBushCluster,
                    'secretgarden': createFlowerBushCluster,
                    'plain': createFlowerBushCluster,
                    'grove': createForestCluster,
                    'flowerfield': createFlowerBushCluster,
                    'castlelawn': createRuinsCluster,
                    'pasture': createFlowerBushCluster,
                    'orchard': createForestCluster,
                    'zen': createRockClusterGrey,
                    'mistymeadow': createFlowerBushCluster,
                    'magicclearing': createForestCluster,
                    'fairyvalley': createFlowerBushCluster,
                    'enchanted': createForestCluster,
                    'paradise': createFlowerBushCluster,
                    'eternal': createFlowerBushCluster,
                    // Chapter 2: Wilderness themes
                    'forest': createForestCluster,
                    'beach': createBeachCluster,
                    'desert': createDesertCluster,
                    'canyon': createDesertCluster,
                    'bamboo': createBambooCluster,
                    'swamp': createSwampCluster,
                    'savanna': createSavannaCluster,
                    'jungle': createForestCluster,
                    'coast': createBeachCluster,
                    'dunes': createDesertCluster,
                    'amazon': createForestCluster,
                    'oasis': createDesertCluster,
                    'mangrove': createSwampCluster,
                    'steppe': createFlowerBushCluster,
                    'pineforest': createForestCluster,
                    'stormyshore': createBeachCluster,
                    'icedesert': createSnowCluster,
                    'bayou': createSwampCluster,
                    'petrified': createRuinsCluster,
                    'wasteland': createDesertCluster,
                    // Chapter 3: Ancient themes
                    'village': createVillageCluster,
                    'ruins': createRuinsCluster,
                    'temple': createRuinsCluster,
                    'ghosttown': createGhostTownCluster,
                    'castleruins': createRuinsCluster,
                    'lostcity': createRuinsCluster,
                    'monastery': createRuinsCluster,
                    'palace': createRuinsCluster,
                    'tower': createRuinsCluster,
                    'fortress': createRuinsCluster,
                    'coliseum': createRuinsCluster,
                    'pyramid': createDesertCluster,
                    'cathedral': createRuinsCluster,
                    'citadel': createRuinsCluster,
                    'amphitheater': createRuinsCluster,
                    'pagoda': createBambooCluster,
                    'ziggurat': createDesertCluster,
                    'aztec': createForestCluster,
                    'library': createRuinsCluster,
                    'throne': createRuinsCluster,
                    // Chapter 4: Hostile themes
                    'cave': createCaveCluster,
                    'volcano': createVolcanoCluster,
                    'crystal': createCrystalCluster,
                    'dark': createDarkCluster,
                    'icyabyss': createSnowCluster,
                    'lavaland': createVolcanoCluster,
                    'toxic': createCaveCluster,
                    'void': createDarkCluster,
                    'frozenhell': createSnowCluster,
                    'peak': createSnowCluster,
                    'abyss': createDarkCluster,
                    'corrupted': createDarkCluster,
                    'glacier': createSnowCluster,
                    'lunar': createRockClusterGrey,
                    'firestorm': createVolcanoCluster,
                    'oceanabyss': createCaveCluster,
                    'nothingness': createDarkCluster,
                    'inverted': createDarkCluster,
                    'fracture': createCrystalCluster,
                    'chaos': createVolcanoCluster
                };

                const creator = clusterMap[levelType] || createRockClusterGrey;
                creator(pos.x, pos.z);
            });
        }

        function createRockClusterGrey(x, z) {
            createRockCluster(x, z, 0x696969);
        }

        function createSavannaCluster(x, z) {
            // Acacias et herbes hautes
            for (let i = 0; i < 2; i++) {
                const tx = x + (seededRandom() - 0.5) * 6;
                const tz = z + (seededRandom() - 0.5) * 6;
                // Acacia tree (flat top)
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 4),
                    new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                );
                trunk.position.set(tx, 2, tz);
                scene.add(trunk); levelObjects.push(trunk);
                addSolidObject(tx, tz, 0.4, 4);

                const crown = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 3, 0.5),
                    new THREE.MeshLambertMaterial({ color: 0x228b22 })
                );
                crown.position.set(tx, 4.5, tz);
                scene.add(crown); levelObjects.push(crown);
            }
        }

        // === FONCTIONS DE CR√âATION DE CLUSTERS TH√âMATIQUES ===

        function createFlowerBushCluster(x, z) {
            // Buissons avec fleurs
            for (let i = 0; i < 5; i++) {
                const r = 1 + seededRandom() * 0.5;
                const bx = x + (seededRandom() - 0.5) * 5;
                const bz = z + (seededRandom() - 0.5) * 5;
                const bush = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 8), new THREE.MeshLambertMaterial({ color: 0x2ecc71 }));
                bush.position.set(bx, r * 0.5, bz);
                scene.add(bush); levelObjects.push(bush);
                addSolidObject(bx, bz, r, r * 1.5); // Hauteur corrig√©e
            }
        }

        function createForestCluster(x, z) {
            // Arbres
            for (let i = 0; i < 3; i++) {
                const tx = x + (seededRandom() - 0.5) * 6;
                const tz = z + (seededRandom() - 0.5) * 6;
                createTree(tx, tz, 0.8 + seededRandom() * 0.4);
            }
        }

        function createBeachCluster(x, z) {
            // Palmiers avec feuilles et rochers de plage
            for (let i = 0; i < 2; i++) {
                const px = x + (seededRandom() - 0.5) * 5;
                const pz = z + (seededRandom() - 0.5) * 5;
                const palm = new THREE.Group();
                // Tronc
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 4, 8), new THREE.MeshLambertMaterial({ color: 0x8d6e63 }));
                trunk.position.y = 2;
                trunk.rotation.z = seededRandom() * 0.2 - 0.1;
                palm.add(trunk);
                // Feuilles (6 feuilles autour du sommet)
                for (let j = 0; j < 6; j++) {
                    const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.25, 2.5, 4), new THREE.MeshLambertMaterial({ color: 0x27ae60 }));
                    leaf.position.set(0, 4, 0);
                    leaf.rotation.z = Math.PI / 3;
                    leaf.rotation.y = (j / 6) * Math.PI * 2;
                    palm.add(leaf);
                }
                palm.position.set(px, 0, pz);
                scene.add(palm); levelObjects.push(palm);
                addSolidObject(px, pz, 0.4, 5); // Palmier = 5 de haut
            }
            // Rochers de plage
            for (let i = 0; i < 3; i++) {
                const r = 0.5 + seededRandom() * 0.5;
                const rx = x + (seededRandom() - 0.5) * 6;
                const rz = z + (seededRandom() - 0.5) * 6;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0xbdc3c7 }));
                rock.position.set(rx, r * 0.3, rz);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(rx, rz, r * 0.8, r); // Rocher = hauteur du rayon
            }
        }

        function createVillageCluster(x, z) {
            // Tonneaux et caisses
            for (let i = 0; i < 4; i++) {
                const bx = x + (seededRandom() - 0.5) * 5;
                const bz = z + (seededRandom() - 0.5) * 5;
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 16), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                barrel.position.set(bx, 0.6, bz);
                scene.add(barrel); levelObjects.push(barrel);
                addSolidObject(bx, bz, 0.5, 1.2); // Tonneau = 1.2 de haut
            }
        }

        function createSwampCluster(x, z) {
            // Arbres morts
            for (let i = 0; i < 3; i++) {
                const tx = x + (seededRandom() - 0.5) * 5;
                const tz = z + (seededRandom() - 0.5) * 5;
                const tree = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 4, 6), new THREE.MeshLambertMaterial({ color: 0x4e342e }));
                tree.position.set(tx, 2, tz);
                tree.rotation.z = seededRandom() * 0.3;
                scene.add(tree); levelObjects.push(tree);
                addSolidObject(tx, tz, 0.4, 4); // Arbre mort = 4 de haut
            }
        }

        function createBambooCluster(x, z) {
            // Bambous
            for (let i = 0; i < 8; i++) {
                const bx = x + (seededRandom() - 0.5) * 4;
                const bz = z + (seededRandom() - 0.5) * 4;
                const bamboo = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5 + seededRandom() * 3, 8), new THREE.MeshLambertMaterial({ color: 0x7cb342 }));
                bamboo.position.set(bx, 2.5, bz);
                scene.add(bamboo); levelObjects.push(bamboo);
                addSolidObject(bx, bz, 0.15, 6); // Bambou = 6 de haut
            }
        }

        function createDesertCluster(x, z) {
            // Dune + cactus
            const radius = 4 + seededRandom() * 3;
            const dune = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: 0xdaa520 }));
            dune.position.set(x, 0, z);
            scene.add(dune); levelObjects.push(dune);
            // Plateforme en d√¥me pour marcher dessus
            platforms.push({
                circular: true,
                centerX: x,
                centerZ: z,
                radius: radius,
                y: radius * 0.7,
                isDome: true,
                domeRadius: radius
            });
            // Cactus
            const cx = x + (seededRandom() - 0.5) * 8;
            const cz = z + (seededRandom() - 0.5) * 8;
            const cactus = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 2, 8), new THREE.MeshLambertMaterial({ color: 0x27ae60 }));
            cactus.position.set(cx, 1, cz);
            scene.add(cactus); levelObjects.push(cactus);
            addSolidObject(cx, cz, 0.4, 2); // Cactus = 2 de haut
        }

        function createCemeteryCluster(x, z) {
            // Tombes
            for (let i = 0; i < 5; i++) {
                const tx = x + (seededRandom() - 0.5) * 6;
                const tz = z + (seededRandom() - 0.5) * 6;
                const tomb = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.5, 0.2), new THREE.MeshLambertMaterial({ color: 0x7f8c8d }));
                tomb.position.set(tx, 0.75, tz);
                scene.add(tomb); levelObjects.push(tomb);
                addSolidObject(tx, tz, 0.5, 1.5); // Tombe = 1.5 de haut
            }
        }

        function createRuinsCluster(x, z) {
            // Piliers cass√©s et blocs
            for (let i = 0; i < 3; i++) {
                const px = x + (seededRandom() - 0.5) * 5;
                const pz = z + (seededRandom() - 0.5) * 5;
                const h = 2 + seededRandom() * 3;
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, h, 8), new THREE.MeshLambertMaterial({ color: 0x808080 }));
                pillar.position.set(px, h / 2, pz);
                scene.add(pillar); levelObjects.push(pillar);
                addSolidObject(px, pz, 0.8, h); // Pilier = hauteur variable
            }
        }

        function createCaveCluster(x, z) {
            // Stalagmites
            for (let i = 0; i < 5; i++) {
                const sx = x + (seededRandom() - 0.5) * 5;
                const sz = z + (seededRandom() - 0.5) * 5;
                const h = 1 + seededRandom() * 2;
                const stalagmite = new THREE.Mesh(new THREE.ConeGeometry(0.4, h, 6), new THREE.MeshLambertMaterial({ color: 0x4e342e }));
                stalagmite.position.set(sx, h / 2, sz);
                scene.add(stalagmite); levelObjects.push(stalagmite);
                addSolidObject(sx, sz, 0.4, h); // Stalagmite = hauteur variable
            }
        }

        function createGhostTownCluster(x, z) {
            // Petite structure abandonn√©e
            const struct = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 3), new THREE.MeshLambertMaterial({ color: 0x5d5d5d }));
            struct.position.set(x, 1, z);
            scene.add(struct); levelObjects.push(struct);
            addSolidObject(x, z, 2, 2); // Structure = 2 de haut
        }

        function createSnowCluster(x, z) {
            // Sapins enneig√©s
            for (let i = 0; i < 3; i++) {
                const px = x + (seededRandom() - 0.5) * 5;
                const pz = z + (seededRandom() - 0.5) * 5;
                const pine = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 1.5, 8), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                trunk.position.y = 0.75;
                pine.add(trunk);
                for (let j = 0; j < 3; j++) {
                    const layer = new THREE.Mesh(new THREE.ConeGeometry(1.5 - j * 0.3, 1.5, 8), new THREE.MeshLambertMaterial({ color: 0xeceff1 }));
                    layer.position.y = 2 + j;
                    pine.add(layer);
                }
                pine.position.set(px, 0, pz);
                scene.add(pine); levelObjects.push(pine);
                addSolidObject(px, pz, 0.3, 6); // Sapin = 6 de haut
            }
        }

        function createVolcanoCluster(x, z) {
            // Rochers volcaniques noirs + petite flaque de lave
            for (let i = 0; i < 4; i++) {
                const r = 1 + seededRandom() * 1.5;
                const rx = x + (seededRandom() - 0.5) * 6;
                const rz = z + (seededRandom() - 0.5) * 6;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x37474f }));
                rock.position.set(rx, r * 0.5, rz);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(rx, rz, r * 0.8, r * 1.5); // Rocher - hauteur corrig√©e
            }
            // Petite flaque de lave
            const lava = new THREE.Mesh(new THREE.CircleGeometry(1 + seededRandom(), 16), new THREE.MeshBasicMaterial({ color: 0xff5722 }));
            lava.rotation.x = -Math.PI / 2;
            lava.position.set(x, 0.1, z);
            scene.add(lava); levelObjects.push(lava);
        }

        function createCrystalCluster(x, z) {
            // Cristaux
            const colors = [0x9b59b6, 0x3498db, 0x1abc9c, 0xe74c3c];
            for (let i = 0; i < 4; i++) {
                const cx = x + (seededRandom() - 0.5) * 4;
                const cz = z + (seededRandom() - 0.5) * 4;
                const h = 2 + seededRandom() * 2;
                const crystal = new THREE.Mesh(new THREE.ConeGeometry(0.6, h, 6), new THREE.MeshLambertMaterial({ color: colors[i], transparent: true, opacity: 0.7 }));
                crystal.position.set(cx, h / 2, cz);
                scene.add(crystal); levelObjects.push(crystal);
                addSolidObject(cx, cz, 0.6, h); // Cristal = hauteur variable
            }
        }

        function createDarkCluster(x, z) {
            // Piliers noirs flottants
            for (let i = 0; i < 3; i++) {
                const px = x + (seededRandom() - 0.5) * 5;
                const pz = z + (seededRandom() - 0.5) * 5;
                const pillar = new THREE.Mesh(new THREE.BoxGeometry(2, 8, 2), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
                pillar.position.set(px, 4, pz);
                scene.add(pillar); levelObjects.push(pillar);
                addSolidObject(px, pz, 1.5, 8); // Pilier noir = 8 de haut
            }
        }

        function createRockCluster(x, z, color) {
            // Groupe de rochers g√©n√©rique
            for (let i = 0; i < 4; i++) {
                const r = 1 + seededRandom() * 1.5;
                const rx = x + (seededRandom() - 0.5) * 6;
                const rz = z + (seededRandom() - 0.5) * 6;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: color }));
                rock.position.set(rx, r * 0.5, rz);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(rx, rz, r * 1.3, r * 1.5); // Rocher - hitbox √©largie
            }
        }

        // Fonction helper pour ajouter un objet solide avec collision circulaire
        // height = hauteur de l'objet sur lequel on peut se tenir debout
        function addSolidObject(x, z, radius, height = 1.5) {
            solidObjects.push({ x: x, z: z, radius: radius, height: height, type: 'circle' });
        }

        // Fonction helper pour ajouter un mur solide avec collision rectangulaire
        function addSolidWall(x, z, width, depth, height = 1.5) {
            solidObjects.push({ x: x, z: z, width: width, depth: depth, height: height, type: 'rect' });
        }

        // G√©n√©rateur de nombres al√©atoires avec graine (seed)
        // Produit toujours les m√™mes nombres pour la m√™me graine
        let randomSeed = 1;
        function seededRandom() {
            randomSeed = (randomSeed * 9301 + 49297) % 233280;
            return randomSeed / 233280;
        }

        function initRandomSeed(chapter, level) {
            // Cr√©er une graine unique bas√©e sur le chapitre et le niveau
            randomSeed = chapter * 1000 + level * 37 + 12345;

            // Les positions des boutons sont maintenant √©crites en dur dans levelConfigs
            // avec une progression de difficult√© appropri√©e
        }

        function loadLevel() {
            // Initialiser le g√©n√©rateur al√©atoire avec une graine fixe pour ce niveau
            initRandomSeed(currentChapter, currentLevel);

            // Clear previous level
            levelObjects.forEach(obj => scene.remove(obj));
            levelObjects = [];
            platforms = [];
            solidObjects = []; // Reset collisions
            level20Key = null;
            level20Door = null;
            level20Rock = null;
            level20RockCollision = null;
            hasKey = false;
            doorOpened = false;

            // Reset puzzle state
            puzzleState = {
                switches: [false, false, false],
                switchOrder: [],
                gems: [false, false, false],
                gemsCollected: 0,
                torches: [false, false, false],
                torchesLit: 0,
                keys: [false, false],
                keysCollected: 0,
                doors: [false, false],
                doorsOpened: 0,
                runesCollected: 0,
                leverPulled: false,
                rockPushed: false,
                wallBroken: false,
                codeEntered: false,
                currentCode: "",
                correctCode: "1234",
                plateSequence: [],
                correctPlateSequence: [1, 3, 2, 4],
                crystalOrder: [],
                correctCrystalOrder: ["red", "blue", "green", "yellow"],
                mapFound: false,
                waterReleased: false,
                pillarsAligned: [false, false, false],
                ghostFollowed: false,
                seedPlanted: false,
                seedWatered: false,
                treeGrown: false,
                mazeCompleted: false,
                starsAligned: false,
                ultimateSteps: 0
            };

            if (redButton) scene.remove(redButton);

            const levelKey = getLevelKey(currentChapter, currentLevel);
            const config = levelConfigs[levelKey];

            // Is this a puzzle level (Chapter 5)?
            const isPuzzleLevel = currentChapter === 5;
            level20ButtonHidden = isPuzzleLevel;

            // Sky and fog
            scene.background = new THREE.Color(config.skyColor);
            scene.fog = new THREE.FogExp2(config.fogColor, config.fogDensity);

            // Ground (visible des deux c√¥t√©s pour √©viter la transparence)
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: config.groundColor, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            levelObjects.push(ground);

            // === √éLES DISTANTES (d√©coration sur les bords) ===
            createDistantIslands(config.groundColor, config.skyColor);

            // Stocker la position du bouton pour les fonctions de niveau
            nextButtonPos = { x: config.buttonPos.x, z: config.buttonPos.z };

            // === FAUX GROUPEMENTS D'OBJETS (pour tromper le joueur) - sauf puzzles ===
            if (!isPuzzleLevel) {
                createFakeHidingSpots(config.levelType);
            }

            // Create level based on levelType
            createLevelByType(config.levelType || config.puzzleType);

            // Create red button (hidden for puzzle levels)
            createRedButton(config.buttonPos.x, config.buttonPos.y, config.buttonPos.z);
            if (isPuzzleLevel) {
                redButton.visible = false;
            } else {
                // Cacher le bouton selon la difficult√©
                createButtonHidingSpot(config.difficulty || 'easy', config.levelType);
            }

            // Reset player position
            if (config.levelType === 'volcano') {
                // Niveau volcan: spawn au sommet dans la lave
                player.position.set(0, 21, 0);
            } else {
                player.position.set(0, 0, 0);
            }
            playerVelocity = { x: 0, y: 0, z: 0 };
            isGrounded = true;

            // Update UI
            document.getElementById('currentLevel').textContent = `${currentChapter}-${currentLevel}`;
            document.getElementById('levelName').textContent = config.name;
            document.getElementById('hintText').textContent = config.hint;
        }

        function createTree(x, z, scale = 1) {
            const tree = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3 * scale, 0.5 * scale, 3 * scale, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1.5 * scale;
            trunk.castShadow = true;
            tree.add(trunk);

            // Leaves (multiple layers)
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            for (let i = 0; i < 3; i++) {
                const leavesGeometry = new THREE.ConeGeometry((2 - i * 0.4) * scale, (2 - i * 0.3) * scale, 8);
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = (3.5 + i * 1.2) * scale;
                leaves.castShadow = true;
                tree.add(leaves);
            }

            tree.position.set(x, 0, z);
            scene.add(tree);
            levelObjects.push(tree);
            // Collision pour tout l'arbre (tronc + feuilles)
            // Rayon des feuilles les plus larges = 2 * scale
            // Hauteur totale = 7.3 * scale (sommet des feuilles)
            addSolidObject(x, z, 2 * scale, 7.3 * scale);
            return tree;
        }

        function createPalm(x, z, scale = 1) {
            const palm = new THREE.Group();

            // Tronc du palmier - m√™me style que createBeachLevel
            const trunkGeometry = new THREE.CylinderGeometry(0.3 * scale, 0.4 * scale, 5 * scale, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8d6e63 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5 * scale;
            trunk.rotation.z = seededRandom() * 0.2 - 0.1;
            trunk.castShadow = true;
            palm.add(trunk);

            // Feuilles de palmier - m√™me style que createBeachLevel
            const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x27ae60 });
            for (let i = 0; i < 6; i++) {
                const leafGeometry = new THREE.ConeGeometry(0.3 * scale, 3 * scale, 4);
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.set(0, 5 * scale, 0);
                leaf.rotation.z = Math.PI / 3;
                leaf.rotation.y = (i / 6) * Math.PI * 2;
                leaf.castShadow = true;
                palm.add(leaf);
            }

            palm.position.set(x, 0, z);
            scene.add(palm);
            levelObjects.push(palm);
            addSolidObject(x, z, 0.35 * scale, 5 * scale);
            return palm;
        }

        function createCactus(x, z, scale = 1) {
            const cactus = new THREE.Group();

            // Corps principal
            const bodyGeometry = new THREE.CylinderGeometry(0.4 * scale, 0.5 * scale, 3 * scale, 8);
            const cactusMaterial = new THREE.MeshLambertMaterial({ color: 0x2e8b57 });
            const body = new THREE.Mesh(bodyGeometry, cactusMaterial);
            body.position.y = 1.5 * scale;
            body.castShadow = true;
            cactus.add(body);

            // Bras gauche
            const armGeometry = new THREE.CylinderGeometry(0.25 * scale, 0.3 * scale, 1.5 * scale, 8);
            const leftArm = new THREE.Mesh(armGeometry, cactusMaterial);
            leftArm.position.set(-0.6 * scale, 2 * scale, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true;
            cactus.add(leftArm);

            // Bras droit
            const rightArm = new THREE.Mesh(armGeometry, cactusMaterial);
            rightArm.position.set(0.6 * scale, 2.5 * scale, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true;
            cactus.add(rightArm);

            cactus.position.set(x, 0, z);
            scene.add(cactus);
            levelObjects.push(cactus);
            addSolidObject(x, z, 0.5 * scale, 3 * scale);
            return cactus;
        }

        function createRock(x, z, scale = 1) {
            const rockGeometry = new THREE.DodecahedronGeometry(scale, 0);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, scale * 0.5, z);
            rock.rotation.set(seededRandom(), seededRandom(), seededRandom());
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
            levelObjects.push(rock);

            // Plateforme pour pouvoir monter sur le rocher
            platforms.push({
                circular: true,
                centerX: x,
                centerZ: z,
                radius: scale,
                y: scale * 1.2 // Sommet du rocher
            });

            return rock;
        }

        function createHouse(x, z, rotation = 0) {
            const house = new THREE.Group();

            // Base
            const baseGeometry = new THREE.BoxGeometry(6, 4, 5);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xdeb887 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 2;
            base.castShadow = true;
            base.receiveShadow = true;
            house.add(base);

            // Roof
            const roofGeometry = new THREE.ConeGeometry(5, 3, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 5.5;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            house.add(roof);

            // Door
            const doorGeometry = new THREE.BoxGeometry(1.2, 2.5, 0.1);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.25, 2.55);
            house.add(door);

            house.position.set(x, 0, z);
            house.rotation.y = rotation;
            scene.add(house);
            levelObjects.push(house);
            // Grande collision - maison infranchissable (hauteur 100 = impossible √† sauter)
            addSolidObject(x, z, 4, 100);
            return house;
        }

        function createPillar(x, z, height = 8, broken = false) {
            const pillar = new THREE.Group();

            const pillarHeight = broken ? height * (0.3 + seededRandom() * 0.4) : height;
            const pillarGeometry = new THREE.CylinderGeometry(0.8, 1, pillarHeight, 8);
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const pillarMesh = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillarMesh.position.y = pillarHeight / 2;
            pillarMesh.castShadow = true;
            pillarMesh.receiveShadow = true;
            pillar.add(pillarMesh);

            // Top decoration
            if (!broken) {
                const topGeometry = new THREE.BoxGeometry(2, 0.5, 2);
                const top = new THREE.Mesh(topGeometry, pillarMaterial);
                top.position.y = pillarHeight + 0.25;
                top.castShadow = true;
                pillar.add(top);
            }

            pillar.position.set(x, 0, z);
            scene.add(pillar);
            levelObjects.push(pillar);
            // Collision pour le pilier
            addSolidObject(x, z, 1, height); // Pilier = hauteur variable
            return pillar;
        }

        function createPlatform(x, y, z, width = 5, depth = 5) {
            const platformGeometry = new THREE.BoxGeometry(width, 1, depth);
            const platformMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            levelObjects.push(platform);
            platforms.push({
                mesh: platform,
                minX: x - width / 2,
                maxX: x + width / 2,
                minZ: z - depth / 2,
                maxZ: z + depth / 2,
                y: y + 0.5
            });
            return platform;
        }

        function createForestLevel() {
            // Stocker les positions des objets pour √©viter les chevauchements
            const occupiedPositions = [];

            function isPositionOccupied(x, z, minDist = 3) {
                for (const pos of occupiedPositions) {
                    const dx = x - pos.x;
                    const dz = z - pos.z;
                    if (Math.sqrt(dx * dx + dz * dz) < minDist + pos.radius) return true;
                }
                return false;
            }

            // Many trees scattered around
            for (let i = 0; i < 40; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                if (Math.abs(x) > 5 || Math.abs(z) > 5) {
                    const scale = 0.8 + seededRandom() * 0.6;
                    createTree(x, z, scale);
                    occupiedPositions.push({ x, z, radius: 2 * scale });
                }
            }

            // Tree hiding the button (at x:25, z:-20)
            createTree(25, -18, 1.5);
            occupiedPositions.push({ x: 25, z: -18, radius: 3 });
            createTree(27, -21, 1.2);
            occupiedPositions.push({ x: 27, z: -21, radius: 2.4 });
            createTree(23, -22, 1.3);
            occupiedPositions.push({ x: 23, z: -22, radius: 2.6 });

            // Some rocks - √©viter les arbres
            for (let i = 0; i < 15; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 70;
                    z = (seededRandom() - 0.5) * 70;
                    attempts++;
                } while (isPositionOccupied(x, z, 2) && attempts < 20);

                if (!isPositionOccupied(x, z, 2)) {
                    const scale = 0.5 + seededRandom() * 1;
                    createRock(x, z, scale);
                    occupiedPositions.push({ x, z, radius: scale });
                }
            }

            // Bushes (small green spheres) avec collision - √©viter les arbres et rochers
            const bushMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5a27 });
            for (let i = 0; i < 25; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 80;
                    z = (seededRandom() - 0.5) * 80;
                    attempts++;
                } while (isPositionOccupied(x, z, 1.5) && attempts < 20);

                if (!isPositionOccupied(x, z, 1.5)) {
                    const radius = 0.5 + seededRandom() * 0.5;
                    const bushGeometry = new THREE.SphereGeometry(radius, 8, 8);
                    const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                    bush.position.set(x, 0.3, z);
                    bush.castShadow = true;
                    scene.add(bush);
                    levelObjects.push(bush);
                    addSolidObject(x, z, radius, 0.3 + radius);
                    occupiedPositions.push({ x, z, radius });
                }
            }
        }

        function createVillageLevel() {
            // Houses
            createHouse(10, 10, 0);
            createHouse(-15, 5, Math.PI / 4);
            createHouse(5, -15, -Math.PI / 6);
            createHouse(-10, -20, Math.PI / 2);

            // Broken cart hiding button (at x:-18, z:22)
            const cart = new THREE.Group();
            const cartBody = new THREE.BoxGeometry(4, 1.5, 2);
            const cartMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const cartMesh = new THREE.Mesh(cartBody, cartMaterial);
            cartMesh.position.y = 0.75;
            cartMesh.rotation.z = 0.2;
            cartMesh.castShadow = true;
            cart.add(cartMesh);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.2, 16);
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel1.rotation.z = Math.PI / 2;
            wheel1.position.set(-1.5, 0.3, 1.2);
            cart.add(wheel1);
            const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel2.rotation.z = Math.PI / 2;
            wheel2.position.set(1.5, 0.6, 1.2);
            cart.add(wheel2);

            cart.position.set(-18, 0, 20);
            scene.add(cart);
            levelObjects.push(cart);
            addSolidObject(-18, 20, 2.5, 2); // Charrette = 2 de haut

            // Barrels avec collision
            const barrelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 16);
            const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const barrelPositions = [[8, 15], [-8, -10], [20, -5], [-20, 15]];
            barrelPositions.forEach(pos => {
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.position.set(pos[0], 0.6, pos[1]);
                barrel.castShadow = true;
                scene.add(barrel);
                levelObjects.push(barrel);
                addSolidObject(pos[0], pos[1], 0.5, 1.2); // Tonneau = 1.2 de haut
            });

            // Fences avec collision
            const fenceMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            for (let i = -20; i < 25; i += 3) {
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 0.2), fenceMaterial);
                post.position.set(i, 0.75, 30);
                post.castShadow = true;
                scene.add(post);
                levelObjects.push(post);
                addSolidObject(i, 30, 0.3, 2); // Poteau = 2 de haut
            }

            // Some trees
            for (let i = 0; i < 10; i++) {
                createTree((seededRandom() - 0.5) * 60, (seededRandom() - 0.5) * 60, 0.7 + seededRandom() * 0.5);
            }
        }

        function createCanyonLevel() {
            // Rock walls
            for (let i = 0; i < 30; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const scale = 1 + seededRandom() * 3;
                createRock(x, z, scale);
            }

            // Rock formations hiding the button (at x:18, z:30) - d√©cal√© √† c√¥t√©
            createRock(14, 26, 2.5);
            createRock(20, 29, 2);
            createRock(13, 32, 1.8);
            createRock(21, 27, 1.5);

            // Canyon walls (tall rocks on sides)
            for (let i = -40; i < 40; i += 5) {
                createRock(-40 + seededRandom() * 5, i, 3 + seededRandom() * 2);
                createRock(40 - seededRandom() * 5, i, 3 + seededRandom() * 2);
            }

            // Cacti avec collision
            const cactusMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const cactus = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 2, 8), cactusMaterial);
                body.position.y = 1;
                cactus.add(body);

                const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.8, 8), cactusMaterial);
                arm1.position.set(0.4, 1.2, 0);
                arm1.rotation.z = -Math.PI / 4;
                cactus.add(arm1);

                cactus.position.set(x, 0, z);
                cactus.castShadow = true;
                scene.add(cactus);
                levelObjects.push(cactus);
                addSolidObject(x, z, 0.4, 3); // Cactus = 3 de haut
            }
        }

        function createRuinsLevel() {
            // Pillars in a maze-like pattern
            const pillarPositions = [
                [-20, -20], [-20, -10], [-20, 0], [-20, 10], [-20, 20],
                [-10, -20], [-10, 0], [-10, 20],
                [0, -20], [0, -10], [0, 10], [0, 20],
                [10, -20], [10, 0], [10, 20],
                [20, -20], [20, -10], [20, 0], [20, 10], [20, 20]
            ];

            pillarPositions.forEach(pos => {
                createPillar(pos[0], pos[1], 6 + seededRandom() * 4, seededRandom() > 0.6);
            });

            // Hiding pillars around button (at x:-25, z:-25)
            createPillar(-25, -22, 8, false);
            createPillar(-22, -25, 7, true);
            createPillar(-28, -25, 6, false);
            createPillar(-25, -28, 5, true);

            // Fallen pillars avec collision
            for (let i = 0; i < 5; i++) {
                const x = (seededRandom() - 0.5) * 40;
                const z = (seededRandom() - 0.5) * 40;
                const fallenGeometry = new THREE.CylinderGeometry(0.8, 1, 6, 8);
                const fallenMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                const fallen = new THREE.Mesh(fallenGeometry, fallenMaterial);
                fallen.rotation.z = Math.PI / 2;
                fallen.position.set(x, 0.8, z);
                fallen.castShadow = true;
                fallen.receiveShadow = true;
                scene.add(fallen);
                levelObjects.push(fallen);
                // Collision lin√©aire pour pilier tomb√©
                for (let offset = -2.5; offset <= 2.5; offset += 1) {
                    addSolidObject(x + offset, z, 1, 2); // Pilier tomb√©
                }
            }

            // Stone blocks scattered avec collision
            const blockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
            for (let i = 0; i < 20; i++) {
                const size = 1 + seededRandom();
                const x = (seededRandom() - 0.5) * 50;
                const z = (seededRandom() - 0.5) * 50;
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(size, 0.5 + seededRandom() * 0.5, size),
                    blockMaterial
                );
                block.position.set(x, 0.25, z);
                block.castShadow = true;
                block.receiveShadow = true;
                scene.add(block);
                levelObjects.push(block);
                addSolidObject(x, z, size * 0.6, size); // Bloc de ruine
            }
        }

        function createCrystalLevel() {
            // Niveau 18: Labyrinthe de Cristaux - tr√®s difficile √† trouver le bouton

            // Fonction pour cr√©er un cristal avec collision
            const createCrystal = (x, z, height, color) => {
                const crystal = new THREE.Group();
                const crystalGeometry = new THREE.ConeGeometry(0.8, height, 6);
                const crystalMaterial = new THREE.MeshLambertMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const crystalMesh = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystalMesh.position.y = height / 2;
                crystalMesh.castShadow = true;
                crystal.add(crystalMesh);

                // Cristal invers√© en dessous (pour l'effet)
                const crystalBottom = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystalBottom.position.y = height / 4;
                crystalBottom.rotation.x = Math.PI;
                crystalBottom.scale.set(0.5, 0.3, 0.5);
                crystal.add(crystalBottom);

                crystal.position.set(x, 0, z);
                scene.add(crystal);
                levelObjects.push(crystal);
                addSolidObject(x, z, 0.8, 3); // Cristal = 3 de haut
            };

            // Fonction pour cr√©er un mur de cristaux
            const createCrystalWall = (startX, startZ, endX, endZ, segments) => {
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = startX + (endX - startX) * t;
                    const z = startZ + (endZ - startZ) * t;
                    const height = 3 + seededRandom() * 4;
                    const colors = [0x9b59b6, 0x3498db, 0x1abc9c, 0xe74c3c, 0xf39c12];
                    createCrystal(x + (seededRandom() - 0.5) * 2, z + (seededRandom() - 0.5) * 2, height, colors[Math.floor(seededRandom() * colors.length)]);
                }
            };

            // Cr√©er le labyrinthe avec des murs de cristaux
            // Murs ext√©rieurs
            createCrystalWall(-40, -40, 40, -40, 20);
            createCrystalWall(-40, 40, 40, 40, 20);
            createCrystalWall(-40, -40, -40, 40, 20);
            createCrystalWall(40, -40, 40, 40, 20);

            // Murs int√©rieurs du labyrinthe
            createCrystalWall(-30, -20, -10, -20, 8);
            createCrystalWall(10, -30, 10, -10, 8);
            createCrystalWall(-20, 0, 20, 0, 15);
            createCrystalWall(-30, 15, -10, 15, 8);
            createCrystalWall(15, 10, 15, 35, 10);
            createCrystalWall(-35, 25, -20, 25, 6);
            createCrystalWall(0, 20, 0, 35, 6);
            createCrystalWall(-25, -35, -25, -10, 10);
            createCrystalWall(25, -25, 35, -25, 5);
            createCrystalWall(20, 25, 35, 25, 6);

            // Cristaux isol√©s pour remplir et confondre
            for (let i = 0; i < 80; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const height = 1 + seededRandom() * 3;
                const colors = [0x9b59b6, 0x3498db, 0x1abc9c, 0xe74c3c, 0xf39c12, 0x8e44ad];
                createCrystal(x, z, height, colors[Math.floor(seededRandom() * colors.length)]);
            }

            // Gros cristaux pour cacher des zones
            createCrystal(-35, 30, 6, 0x8e44ad);
            createCrystal(-33, 34, 5, 0x9b59b6);
            createCrystal(-37, 33, 4, 0x3498db);
            createCrystal(-34, 31, 5.5, 0x1abc9c);

            // Rochers sombres dispers√©s avec collision
            const darkRockMaterial = new THREE.MeshLambertMaterial({ color: 0x2c2c3e });
            for (let i = 0; i < 30; i++) {
                const radius = 1 + seededRandom() * 2;
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const rockGeometry = new THREE.DodecahedronGeometry(radius, 0);
                const rock = new THREE.Mesh(rockGeometry, darkRockMaterial);
                rock.position.set(x, 0.5 + seededRandom(), z);
                rock.rotation.set(seededRandom(), seededRandom(), seededRandom());
                rock.castShadow = true;
                scene.add(rock);
                levelObjects.push(rock);
                addSolidObject(x, z, radius * 1.3, radius * 1.5); // Rocher - hitbox √©largie
            }

            // Champignons lumineux (d√©coration)
            const mushroomColors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0x95e1d3];
            for (let i = 0; i < 25; i++) {
                const mushroom = new THREE.Group();
                const stemGeometry = new THREE.CylinderGeometry(0.15, 0.2, 0.6, 8);
                const stemMaterial = new THREE.MeshLambertMaterial({ color: 0xeeeeee });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.y = 0.3;
                mushroom.add(stem);

                const capGeometry = new THREE.SphereGeometry(0.4, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const capMaterial = new THREE.MeshLambertMaterial({
                    color: mushroomColors[Math.floor(seededRandom() * mushroomColors.length)],
                    emissive: mushroomColors[Math.floor(seededRandom() * mushroomColors.length)],
                    emissiveIntensity: 0.3
                });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.position.y = 0.6;
                mushroom.add(cap);

                mushroom.position.set(
                    (seededRandom() - 0.5) * 70,
                    0,
                    (seededRandom() - 0.5) * 70
                );
                mushroom.scale.set(0.8 + seededRandom() * 0.5, 0.8 + seededRandom() * 0.5, 0.8 + seededRandom() * 0.5);
                scene.add(mushroom);
                levelObjects.push(mushroom);
            }

            // Lumi√®re d'ambiance suppl√©mentaire (point lights color√©s)
            const pointLight1 = new THREE.PointLight(0x9b59b6, 0.5, 30);
            pointLight1.position.set(-20, 5, -20);
            scene.add(pointLight1);
            levelObjects.push(pointLight1);

            const pointLight2 = new THREE.PointLight(0x3498db, 0.5, 30);
            pointLight2.position.set(20, 5, 20);
            scene.add(pointLight2);
            levelObjects.push(pointLight2);

            const pointLight3 = new THREE.PointLight(0x1abc9c, 0.5, 30);
            pointLight3.position.set(-30, 5, 30);
            scene.add(pointLight3);
            levelObjects.push(pointLight3);
        }

        // === NIVEAU 1: Jardin Fleuri ===
        function createGardenLevel() {
            // Fleurs color√©es
            const flowerColors = [0xff6b6b, 0xfeca57, 0xff9ff3, 0x54a0ff, 0x5f27cd];
            for (let i = 0; i < 100; i++) {
                const flower = new THREE.Group();
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8), new THREE.MeshLambertMaterial({ color: 0x27ae60 }));
                stem.position.y = 0.25;
                flower.add(stem);
                const petals = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshLambertMaterial({ color: flowerColors[Math.floor(seededRandom() * flowerColors.length)] }));
                petals.position.y = 0.5;
                flower.add(petals);
                flower.position.set((seededRandom() - 0.5) * 80, 0, (seededRandom() - 0.5) * 80);
                scene.add(flower);
                levelObjects.push(flower);
            }
            // Quelques arbustes (avec collision)
            for (let i = 0; i < 20; i++) {
                const radius = 1 + seededRandom();
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const bush = new THREE.Mesh(new THREE.SphereGeometry(radius, 8, 8), new THREE.MeshLambertMaterial({ color: 0x2ecc71 }));
                bush.position.set(x, 0.5, z);
                bush.castShadow = true;
                scene.add(bush);
                levelObjects.push(bush);
                addSolidObject(x, z, radius, 0.5 + radius); // Hauteur corrig√©e
            }
            // Buissons pr√®s du bouton (avec collision)
            const hidingBush = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshLambertMaterial({ color: 0x27ae60 }));
            hidingBush.position.set(14, 1, 9);
            scene.add(hidingBush);
            levelObjects.push(hidingBush);
            addSolidObject(14, 9, 2, 2); // Gros buisson = 2 de haut
        }

        // === NIVEAU 3: Plage Tropicale ===
        function createBeachLevel() {
            // Stocker les positions pour √©viter les chevauchements
            const occupiedPositions = [];

            function isPositionOccupied(x, z, minDist = 2) {
                for (const pos of occupiedPositions) {
                    const dx = x - pos.x;
                    const dz = z - pos.z;
                    if (Math.sqrt(dx * dx + dz * dz) < minDist + pos.radius) return true;
                }
                return false;
            }

            // Palmiers avec collision
            const createPalmLocal = (x, z) => {
                const palm = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 5, 8), new THREE.MeshLambertMaterial({ color: 0x8d6e63 }));
                trunk.position.y = 2.5;
                trunk.rotation.z = seededRandom() * 0.2 - 0.1;
                palm.add(trunk);
                for (let i = 0; i < 6; i++) {
                    const leaf = new THREE.Mesh(new THREE.ConeGeometry(0.3, 3, 4), new THREE.MeshLambertMaterial({ color: 0x27ae60 }));
                    leaf.position.set(0, 5, 0);
                    leaf.rotation.z = Math.PI / 3;
                    leaf.rotation.y = (i / 6) * Math.PI * 2;
                    palm.add(leaf);
                }
                palm.position.set(x, 0, z);
                scene.add(palm);
                levelObjects.push(palm);
                addSolidObject(x, z, 0.5, 5);
                occupiedPositions.push({ x, z, radius: 2 });
            };
            for (let i = 0; i < 25; i++) createPalmLocal((seededRandom() - 0.5) * 70, (seededRandom() - 0.5) * 70);
            createPalmLocal(-21, 24);
            createPalmLocal(-19, 26);

            // Rochers de plage avec collision - √©viter les palmiers
            for (let i = 0; i < 15; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 60;
                    z = (seededRandom() - 0.5) * 60;
                    attempts++;
                } while (isPositionOccupied(x, z, 2) && attempts < 20);

                if (!isPositionOccupied(x, z, 2)) {
                    const radius = 0.5 + seededRandom();
                    const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(radius), new THREE.MeshLambertMaterial({ color: 0xbdc3c7 }));
                    rock.position.set(x, radius * 0.5, z);
                    scene.add(rock);
                    levelObjects.push(rock);
                    addSolidObject(x, z, radius * 1.3, radius * 1.5);
                    occupiedPositions.push({ x, z, radius: radius * 1.3 });
                }
            }
            // Eau
            const water = new THREE.Mesh(new THREE.PlaneGeometry(100, 40), new THREE.MeshLambertMaterial({ color: 0x3498db, transparent: true, opacity: 0.7 }));
            water.rotation.x = -Math.PI / 2;
            water.position.set(0, 0.1, 40);
            scene.add(water);
            levelObjects.push(water);
        }

        // === NIVEAU 4: Prairie Verdoyante ===
        function createMeadowLevel() {
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x7dcea0 });
            const darkGrassMaterial = new THREE.MeshLambertMaterial({ color: 0x5daa7a });
            const lightGrassMaterial = new THREE.MeshLambertMaterial({ color: 0x98d9a0 });

            // === 10 000 BRINS D'HERBE AU TOTAL ===

            // Herbes moyennes-hautes partout (3500)
            for (let i = 0; i < 3500; i++) {
                const grass = new THREE.Mesh(
                    new THREE.ConeGeometry(0.1, 1.2 + seededRandom() * 0.8, 4),
                    lightGrassMaterial
                );
                grass.position.set((seededRandom() - 0.5) * 95, 0.7, (seededRandom() - 0.5) * 95);
                scene.add(grass);
                levelObjects.push(grass);
            }

            // Herbes hautes partout (3000)
            for (let i = 0; i < 3000; i++) {
                const grass = new THREE.Mesh(
                    new THREE.ConeGeometry(0.12, 1.5 + seededRandom() * 1, 4),
                    grassMaterial
                );
                grass.position.set((seededRandom() - 0.5) * 95, 0.9, (seededRandom() - 0.5) * 95);
                scene.add(grass);
                levelObjects.push(grass);
            }

            // Herbes tr√®s hautes partout (2500)
            for (let i = 0; i < 2500; i++) {
                const grass = new THREE.Mesh(
                    new THREE.ConeGeometry(0.14, 2 + seededRandom() * 1, 4),
                    darkGrassMaterial
                );
                grass.position.set((seededRandom() - 0.5) * 92, 1.1, (seededRandom() - 0.5) * 92);
                scene.add(grass);
                levelObjects.push(grass);
            }

            // ZONES EXTRA DENSES d'herbes g√©antes (fausses cachettes + vraie) (~1000)
            const tallGrassZones = [
                { x: -25, z: -20 },
                { x: 15, z: 25 },
                { x: -30, z: 30 },
                { x: 35, z: 10 },
                { x: -10, z: -35 },
                { x: 20, z: -30 },
                { x: -35, z: 5 },
                { x: 5, z: 38 },
                { x: -20, z: 15 },
                { x: 38, z: -25 },
                { x: -38, z: -30 },
                { x: 25, z: 35 },
                { x: -15, z: 38 },
                { x: 40, z: 30 },
                { x: -40, z: -15 },
                { x: 30, z: -15 }  // La vraie cachette du bouton
            ];

            tallGrassZones.forEach(zone => {
                for (let i = 0; i < 60 + Math.floor(seededRandom() * 30); i++) {
                    const tallGrass = new THREE.Mesh(
                        new THREE.ConeGeometry(0.16, 2.5 + seededRandom() * 1, 4),
                        [grassMaterial, darkGrassMaterial, lightGrassMaterial][Math.floor(seededRandom() * 3)]
                    );
                    tallGrass.position.set(
                        zone.x + (seededRandom() - 0.5) * 8,
                        1.3 + seededRandom() * 0.3,
                        zone.z + (seededRandom() - 0.5) * 8
                    );
                    scene.add(tallGrass);
                    levelObjects.push(tallGrass);
                }
            });

            // Fleurs dispers√©es partout
            for (let i = 0; i < 200; i++) {
                const flower = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12 + seededRandom() * 0.1, 6, 6),
                    new THREE.MeshLambertMaterial({ color: [0xf1c40f, 0xe74c3c, 0x9b59b6, 0xff69b4, 0xffffff, 0x3498db][Math.floor(seededRandom() * 6)] })
                );
                flower.position.set((seededRandom() - 0.5) * 85, 1 + seededRandom() * 0.5, (seededRandom() - 0.5) * 85);
                scene.add(flower);
                levelObjects.push(flower);
            }
        }

        // === NIVEAU 6: Marais Brumeux ===
        function createSwampLevel() {
            // Eau mar√©cageuse
            const swampWater = new THREE.Mesh(new THREE.PlaneGeometry(80, 80), new THREE.MeshLambertMaterial({ color: 0x2e7d32, transparent: true, opacity: 0.6 }));
            swampWater.rotation.x = -Math.PI / 2;
            swampWater.position.y = 0.05;
            scene.add(swampWater);
            levelObjects.push(swampWater);
            // √élots (on peut marcher dessus)
            for (let i = 0; i < 20; i++) {
                const radiusTop = 2 + seededRandom() * 2;
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const island = new THREE.Mesh(new THREE.CylinderGeometry(radiusTop, radiusTop + 1, 0.5, 8), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                island.position.set(x, 0.2, z);
                scene.add(island);
                levelObjects.push(island);
                // Ajouter comme plateforme circulaire
                platforms.push({
                    mesh: island,
                    circular: true,
                    radius: radiusTop,
                    centerX: x,
                    centerZ: z,
                    y: 0.45
                });
            }
            // Arbres morts avec collision
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const deadTree = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 4, 6), new THREE.MeshLambertMaterial({ color: 0x4e342e }));
                deadTree.position.set(x, 2, z);
                deadTree.rotation.z = seededRandom() * 0.3 - 0.15;
                scene.add(deadTree);
                levelObjects.push(deadTree);
                addSolidObject(x, z, 0.4, 4); // Arbre mort = 4 de haut
            }
            // Cachette du bouton (plus grande √Æle)
            const hideIsland = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 0.6, 8), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
            hideIsland.position.set(28, 0.2, 28);
            scene.add(hideIsland);
            levelObjects.push(hideIsland);
            // Plateforme pour l'√Æle cachette
            platforms.push({
                mesh: hideIsland,
                circular: true,
                radius: 3,
                centerX: 28,
                centerZ: 28,
                y: 0.5
            });
        }

        // === NIVEAU 7: For√™t de Bambou ===
        function createBambooLevel() {
            // Bambou SANS collision (pour la performance)
            const createBambooVisual = (x, z, height) => {
                const bamboo = new THREE.Group();
                const segments = Math.floor(height / 1.5);
                for (let i = 0; i < segments; i++) {
                    const segment = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.4, 6), new THREE.MeshLambertMaterial({ color: 0x7cb342 }));
                    segment.position.y = i * 1.5 + 0.7;
                    bamboo.add(segment);
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(0.17, 0.03, 6, 12), new THREE.MeshLambertMaterial({ color: 0x558b2f }));
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = i * 1.5;
                    bamboo.add(ring);
                }
                bamboo.position.set(x, 0, z);
                scene.add(bamboo);
                levelObjects.push(bamboo);
                // PAS de collision pour les bambous visuels
            };

            // Bambous partout (300 sans collision pour la performance)
            for (let i = 0; i < 300; i++) createBambooVisual((seededRandom() - 0.5) * 85, (seededRandom() - 0.5) * 85, 5 + seededRandom() * 5);

            // Zones denses pour tromper le joueur (plusieurs fausses cachettes)
            const denseZones = [
                { x: -25, z: -30 },  // Vraie cachette (bouton)
                { x: 20, z: 25 },    // Fausse cachette
                { x: -30, z: 20 },   // Fausse cachette
                { x: 30, z: -25 },   // Fausse cachette
                { x: -15, z: 35 },   // Fausse cachette
                { x: 35, z: 10 },    // Fausse cachette
                { x: -35, z: -15 },  // Fausse cachette
                { x: 10, z: -35 },   // Fausse cachette
            ];

            denseZones.forEach(zone => {
                for (let i = 0; i < 40; i++) {
                    createBambooVisual(zone.x + (seededRandom() - 0.5) * 10, zone.z + (seededRandom() - 0.5) * 10, 6 + seededRandom() * 4);
                }
            });
        }

        // === NIVEAU 9: D√©sert Aride ===
        function createDesertLevel() {
            // Stocker les positions pour √©viter les chevauchements
            const occupiedPositions = [];

            function isPositionOccupied(x, z, minDist = 2) {
                for (const pos of occupiedPositions) {
                    const dx = x - pos.x;
                    const dz = z - pos.z;
                    if (Math.sqrt(dx * dx + dz * dz) < minDist + pos.radius) return true;
                }
                return false;
            }

            // Position du bouton pour √©viter de placer des dunes dessus
            const buttonX = nextButtonPos.x;
            const buttonZ = nextButtonPos.z;

            function isTooCloseToButton(x, z, minDist) {
                return Math.sqrt((x - buttonX) ** 2 + (z - buttonZ) ** 2) < minDist;
            }

            // Dunes avec plateforme pour marcher dessus
            for (let i = 0; i < 25; i++) {
                const radius = 5 + seededRandom() * 8;
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 80;
                    z = (seededRandom() - 0.5) * 80;
                    attempts++;
                } while (isTooCloseToButton(x, z, radius + 3) && attempts < 30);

                const dune = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: 0xdaa520 }));
                dune.position.set(x, 0, z);
                scene.add(dune);
                levelObjects.push(dune);

                // Plateforme en d√¥me pour marcher dessus
                platforms.push({
                    circular: true,
                    centerX: x,
                    centerZ: z,
                    radius: radius,
                    y: radius * 0.7,
                    isDome: true,
                    domeRadius: radius
                });

                occupiedPositions.push({ x, z, radius: radius });
            }

            // Cactus avec collision - √©viter les dunes
            for (let i = 0; i < 20; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 70;
                    z = (seededRandom() - 0.5) * 70;
                    attempts++;
                } while (isPositionOccupied(x, z, 3) && attempts < 20);

                if (!isPositionOccupied(x, z, 3)) {
                    const cactus = new THREE.Group();
                    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 3, 8), new THREE.MeshLambertMaterial({ color: 0x27ae60 }));
                    body.position.y = 1.5;
                    cactus.add(body);
                    const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 1.5, 8), new THREE.MeshLambertMaterial({ color: 0x27ae60 }));
                    arm.position.set(0.5, 2, 0);
                    arm.rotation.z = -Math.PI / 4;
                    cactus.add(arm);
                    cactus.position.set(x, 0, z);
                    scene.add(cactus);
                    levelObjects.push(cactus);
                    addSolidObject(x, z, 0.5, 3);
                    occupiedPositions.push({ x, z, radius: 1 });
                }
            }
        }

        // === NIVEAU 10: Cimeti√®re Lugubre ===
        function createCemeteryLevel() {
            // Tombes avec collision
            const createTombstone = (x, z, type) => {
                const tomb = new THREE.Group();
                if (type === 0) {
                    const stone = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.5, 0.2), new THREE.MeshLambertMaterial({ color: 0x7f8c8d }));
                    stone.position.y = 0.75;
                    tomb.add(stone);
                } else {
                    const cross = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.8, 0.15), new THREE.MeshLambertMaterial({ color: 0x95a5a6 }));
                    cross.position.y = 0.9;
                    tomb.add(cross);
                    const crossArm = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.15), new THREE.MeshLambertMaterial({ color: 0x95a5a6 }));
                    crossArm.position.y = 1.3;
                    tomb.add(crossArm);
                }
                tomb.position.set(x, 0, z);
                tomb.rotation.y = seededRandom() * 0.3 - 0.15;
                scene.add(tomb);
                levelObjects.push(tomb);
                addSolidObject(x, z, 0.5, 3); // Cactus/objet = 3 de haut
            };
            for (let i = 0; i < 50; i++) createTombstone((seededRandom() - 0.5) * 70, (seededRandom() - 0.5) * 70, Math.floor(seededRandom() * 2));
            // Arbres morts avec collision
            for (let i = 0; i < 10; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const tree = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 5, 6), new THREE.MeshLambertMaterial({ color: 0x3d3d3d }));
                tree.position.set(x, 2.5, z);
                scene.add(tree);
                levelObjects.push(tree);
                addSolidObject(x, z, 0.5, 3); // Cactus/objet = 3 de haut
            }
            // Cachette: groupe de tombes
            for (let i = 0; i < 8; i++) createTombstone(20 + (seededRandom() - 0.5) * 6, -35 + (seededRandom() - 0.5) * 6, Math.floor(seededRandom() * 2));
        }

        // === NIVEAU 12: Grotte Souterraine ===
        function createCaveLevel() {
            // Stalactites (pas de collision, au plafond)
            for (let i = 0; i < 60; i++) {
                const stalactite = new THREE.Mesh(new THREE.ConeGeometry(0.5, 3 + seededRandom() * 3, 6), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                stalactite.position.set((seededRandom() - 0.5) * 80, 8 + seededRandom() * 5, (seededRandom() - 0.5) * 80);
                stalactite.rotation.x = Math.PI;
                scene.add(stalactite);
                levelObjects.push(stalactite);
            }
            // Stalagmites avec collision
            for (let i = 0; i < 50; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const stalagmite = new THREE.Mesh(new THREE.ConeGeometry(0.4, 2 + seededRandom() * 2, 6), new THREE.MeshLambertMaterial({ color: 0x4e342e }));
                stalagmite.position.set(x, (1 + seededRandom()) / 2, z);
                scene.add(stalagmite);
                levelObjects.push(stalagmite);
                addSolidObject(x, z, 0.4, 2); // Petit objet
            }
            // Rochers avec collision
            for (let i = 0; i < 30; i++) {
                const radius = 1 + seededRandom() * 2;
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(radius), new THREE.MeshLambertMaterial({ color: 0x3e2723 }));
                rock.position.set(x, 0.5, z);
                scene.add(rock);
                levelObjects.push(rock);
                addSolidObject(x, z, radius * 1.3, radius * 1.5); // Rocher - hitbox √©largie
            }
            // Plafond
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 15;
            scene.add(ceiling);
            levelObjects.push(ceiling);
            // Lumi√®res de champignons
            const light1 = new THREE.PointLight(0x00ff88, 0.5, 15);
            light1.position.set(30, 2, 35);
            scene.add(light1);
            levelObjects.push(light1);
        }

        // === NIVEAU 13: Ville Fant√¥me ===
        function createGhostTownLevel() {
            // Maisons abandonn√©es avec collision
            const createBuilding = (x, z, w, h, d) => {
                const building = new THREE.Group();
                const walls = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshLambertMaterial({ color: 0x5d5d5d }));
                walls.position.y = h / 2;
                building.add(walls);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(w * 0.8, 2, 4), new THREE.MeshLambertMaterial({ color: 0x4a4a4a }));
                roof.position.y = h + 1;
                roof.rotation.y = Math.PI / 4;
                building.add(roof);
                building.position.set(x, 0, z);
                scene.add(building);
                levelObjects.push(building);
                // Collision avec hauteur = 100 (infranchissable)
                addSolidObject(x, z, Math.max(w, d) * 0.6, 100);
            };
            createBuilding(-20, 0, 8, 6, 6);
            createBuilding(15, 10, 6, 5, 5);
            createBuilding(-10, -20, 7, 5, 6);
            createBuilding(20, -15, 5, 4, 5);
            createBuilding(-25, 15, 6, 5, 5);
            createBuilding(0, 25, 8, 6, 7);
            createBuilding(-30, -18, 5, 4, 5);
            // Lampadaires cass√©s avec collision
            for (let i = 0; i < 10; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const lamp = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 4, 8), new THREE.MeshLambertMaterial({ color: 0x2c2c2c }));
                lamp.position.set(x, 2, z);
                lamp.rotation.z = seededRandom() * 0.4 - 0.2;
                scene.add(lamp);
                levelObjects.push(lamp);
                addSolidObject(x, z, 0.2, 1); // Petit objet
            }
        }

        // === NIVEAU 14: Temple Ancien ===
        function createTempleLevel() {
            // Structure principale (plateforme sur laquelle on peut marcher)
            const base = new THREE.Mesh(new THREE.BoxGeometry(30, 2, 30), new THREE.MeshLambertMaterial({ color: 0x8d6e63 }));
            base.position.set(0, 1, -20);
            scene.add(base);
            levelObjects.push(base);
            // Ajouter comme plateforme pour pouvoir marcher dessus
            platforms.push({
                mesh: base,
                minX: -15,
                maxX: 15,
                minZ: -35,
                maxZ: -5,
                y: 2,
                blockSides: true // Bloquer les c√¥t√©s quand on est au sol
            });
            // Colonnes avec collision
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * 12;
                const z = -20 + Math.sin(angle) * 12;
                const col = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 8, 12), new THREE.MeshLambertMaterial({ color: 0xa1887f }));
                col.position.set(x, 5, z);
                scene.add(col);
                levelObjects.push(col);
                addSolidObject(x, z, 1, 8); // Colonne = 8 de haut
            }
            // Statues avec collision
            const statuePositions = [[-20, -40], [20, -40], [-20, 0], [20, 0]];
            for (let i = 0; i < 4; i++) {
                const statue = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1), new THREE.MeshLambertMaterial({ color: 0x757575 }));
                body.position.y = 1.5;
                statue.add(body);
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), new THREE.MeshLambertMaterial({ color: 0x757575 }));
                head.position.y = 3.5;
                statue.add(head);
                statue.position.set(statuePositions[i][0], 0, statuePositions[i][1]);
                scene.add(statue);
                levelObjects.push(statue);
                addSolidObject(statuePositions[i][0], statuePositions[i][1], 1, 4); // Statue = 4 de haut
            }
            // Cachette au fond (mur avec collision)
            const wall = new THREE.Mesh(new THREE.BoxGeometry(15, 5, 1), new THREE.MeshLambertMaterial({ color: 0x6d4c41 }));
            wall.position.set(35, 2.5, -33);
            scene.add(wall);
            levelObjects.push(wall);
            // Collision lin√©aire pour le mur (rayon plus large pour couvrir tout le mur)
            for (let wx = 28; wx <= 42; wx += 3) {
                addSolidObject(wx, -33, 2, 100); // Mur infranchissable
            }
        }

        // === NIVEAU 15: Jungle Dense ===
        function createJungleLevel() {
            // Arbres g√©ants avec collision
            for (let i = 0; i < 40; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 8 + seededRandom() * 4, 8), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                trunk.position.y = 4;
                tree.add(trunk);
                const canopy = new THREE.Mesh(new THREE.SphereGeometry(4 + seededRandom() * 2, 8, 8), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
                canopy.position.y = 10;
                tree.add(canopy);
                tree.position.set(x, 0, z);
                scene.add(tree);
                levelObjects.push(tree);
                addSolidObject(x, z, 0.8, 2); // Objet moyen
            }
            // Buissons denses avec collision
            for (let i = 0; i < 80; i++) {
                const radius = 1 + seededRandom();
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const bush = new THREE.Mesh(new THREE.SphereGeometry(radius, 6, 6), new THREE.MeshLambertMaterial({ color: 0x388e3c }));
                bush.position.set(x, 0.5, z);
                scene.add(bush);
                levelObjects.push(bush);
                addSolidObject(x, z, radius, radius * 2); // Buisson = diam√®tre
            }
            // Zone tr√®s dense pour cacher le bouton (bouton √† -35, 41)
            // Buissons autour mais pas sur le bouton
            for (let i = 0; i < 20; i++) {
                const radius = 1.5 + seededRandom();
                let x, z;
                do {
                    x = -38 + (seededRandom() - 0.5) * 10;
                    z = 38 + (seededRandom() - 0.5) * 10;
                } while (Math.abs(x - (-35)) < 2 && Math.abs(z - 41) < 2); // √âviter la zone du bouton
                const denseBush = new THREE.Mesh(new THREE.SphereGeometry(radius, 6, 6), new THREE.MeshLambertMaterial({ color: 0x1b5e20 }));
                denseBush.position.set(x, 1, z);
                scene.add(denseBush);
                levelObjects.push(denseBush);
                addSolidObject(x, z, radius, radius * 2); // Buisson = diam√®tre
            }
        }

        // === NIVEAU 16: Montagne Enneig√©e ===
        function createSnowLevel() {
            // Sapins enneig√©s avec collision
            for (let i = 0; i < 35; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const pine = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 2, 8), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                trunk.position.y = 1;
                pine.add(trunk);
                for (let j = 0; j < 4; j++) {
                    const layer = new THREE.Mesh(new THREE.ConeGeometry(2 - j * 0.4, 2, 8), new THREE.MeshLambertMaterial({ color: 0xeceff1 }));
                    layer.position.y = 2.5 + j * 1.2;
                    pine.add(layer);
                }
                pine.position.set(x, 0, z);
                scene.add(pine);
                levelObjects.push(pine);
                addSolidObject(x, z, 0.4, 2); // Petit objet
            }
            // Rochers enneig√©s avec collision
            for (let i = 0; i < 25; i++) {
                const radius = 1 + seededRandom() * 2;
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(radius), new THREE.MeshLambertMaterial({ color: 0xcfd8dc }));
                rock.position.set(x, 0.5, z);
                scene.add(rock);
                levelObjects.push(rock);
                addSolidObject(x, z, radius * 1.3, radius * 1.5); // Rocher - hitbox √©largie
            }
            // Cong√®re cachant le bouton (avec collision)
            const snowDrift = new THREE.Mesh(new THREE.SphereGeometry(4, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: 0xffffff }));
            snowDrift.position.set(25, 0, -38);
            scene.add(snowDrift);
            levelObjects.push(snowDrift);
            addSolidObject(25, -38, 3, 4); // Gros rocher de neige
        }

        // === NIVEAU 17: Volcan Actif ===
        function createVolcanoLevel() {
            // === VOLCAN TRONQU√â (avec crat√®re de lave au sommet) ===
            // Utilise CylinderGeometry pour cr√©er un c√¥ne tronqu√© (frustum)
            // radiusTop = 8 (crat√®re), radiusBottom = 35 (base), height = 20
            const volcanoGeometry = new THREE.CylinderGeometry(8, 35, 20, 32, 1, true); // Ouvert (sans dessus/dessous)
            const volcanoMaterial = new THREE.MeshLambertMaterial({ color: 0x5d4037, side: THREE.DoubleSide }); // Marron volcanique
            const volcano = new THREE.Mesh(volcanoGeometry, volcanoMaterial);
            volcano.position.set(0, 10, 0); // Centre √† 10, donc base √† 0 et sommet √† 20
            volcano.castShadow = true;
            volcano.receiveShadow = true;
            scene.add(volcano);
            levelObjects.push(volcano);

            // Bord du crat√®re (anneau au sommet)
            const craterRim = new THREE.Mesh(
                new THREE.TorusGeometry(8, 1.5, 8, 32),
                new THREE.MeshLambertMaterial({ color: 0x4a2c2a })
            );
            craterRim.rotation.x = Math.PI / 2;
            craterRim.position.set(0, 20.5, 0);
            scene.add(craterRim);
            levelObjects.push(craterRim);

            // Lave qui remplit tout le crat√®re au sommet
            const lavaCenter = new THREE.Mesh(
                new THREE.CircleGeometry(8, 32),
                new THREE.MeshBasicMaterial({ color: 0xff5722 })
            );
            lavaCenter.rotation.x = -Math.PI / 2;
            lavaCenter.position.set(0, 20.1, 0);
            scene.add(lavaCenter);
            levelObjects.push(lavaCenter);

            // Lave qui brille (effet de lumi√®re)
            const lavaGlow = new THREE.PointLight(0xff5722, 2, 40);
            lavaGlow.position.set(0, 25, 0);
            scene.add(lavaGlow);
            levelObjects.push(lavaGlow);

            // Rochers volcaniques autour (pas sur les pentes pour pouvoir escalader)
            for (let i = 0; i < 40; i++) {
                const radius = 1 + seededRandom() * 2;
                const angle = seededRandom() * Math.PI * 2;
                const dist = 38 + seededRandom() * 10; // Loin du volcan
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(radius), new THREE.MeshLambertMaterial({ color: 0x37474f }));
                rock.position.set(x, 0.5, z);
                scene.add(rock);
                levelObjects.push(rock);
                addSolidObject(x, z, radius * 1.3, radius * 1.5); // Rocher - hitbox √©largie
            }

            // Flaques de lave autour du volcan
            for (let i = 0; i < 15; i++) {
                const angle = seededRandom() * Math.PI * 2;
                const dist = 38 + seededRandom() * 10;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const lava = new THREE.Mesh(new THREE.CircleGeometry(2 + seededRandom() * 3, 16), new THREE.MeshBasicMaterial({ color: 0xff5722 }));
                lava.rotation.x = -Math.PI / 2;
                lava.position.set(x, 0.1, z);
                scene.add(lava);
                levelObjects.push(lava);
            }

            // PAS DE COLLISION sur les pentes - on peut escalader librement !

            // Lumi√®re orange ambiante
            const lavaLight = new THREE.PointLight(0xff5722, 1, 60);
            lavaLight.position.set(0, 10, 0);
            scene.add(lavaLight);
            levelObjects.push(lavaLight);
            // Cachette avec collision (bouton √† -43, -40)
            for (let i = 0; i < 8; i++) {
                const radius = 2 + seededRandom();
                let x, z;
                do {
                    x = -40 + (seededRandom() - 0.5) * 8;
                    z = -40 + (seededRandom() - 0.5) * 8;
                } while (Math.abs(x - (-43)) < 3 && Math.abs(z - (-40)) < 3); // √âviter le bouton
                const hideRock = new THREE.Mesh(new THREE.DodecahedronGeometry(radius), new THREE.MeshLambertMaterial({ color: 0x37474f }));
                hideRock.position.set(x, 1, z);
                scene.add(hideRock);
                levelObjects.push(hideRock);
                addSolidObject(x, z, radius * 1.3, radius * 1.5); // Rocher - hitbox √©largie
            }
        }

        // === NIVEAU 19: Dimension Sombre ===
        function createDarkDimensionLevel() {
            // Piliers flottants avec collision
            for (let i = 0; i < 30; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const pillar = new THREE.Mesh(new THREE.BoxGeometry(2, 10 + seededRandom() * 10, 2), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
                pillar.position.set(x, 5, z);
                scene.add(pillar);
                levelObjects.push(pillar);
                addSolidObject(x, z, 1.5, 3); // Rocher volcanique
            }
            // Orbes lumineux (seule source de lumi√®re)
            const orbColors = [0x9b59b6, 0xe74c3c, 0x3498db];
            for (let i = 0; i < 8; i++) {
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshBasicMaterial({ color: orbColors[i % 3] }));
                orb.position.set((seededRandom() - 0.5) * 60, 3 + seededRandom() * 5, (seededRandom() - 0.5) * 60);
                scene.add(orb);
                levelObjects.push(orb);
                const light = new THREE.PointLight(orbColors[i % 3], 0.5, 20);
                light.position.copy(orb.position);
                scene.add(light);
                levelObjects.push(light);
            }
            // Structures √©tranges avec collision
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const struct = new THREE.Mesh(new THREE.OctahedronGeometry(2), new THREE.MeshLambertMaterial({ color: 0x2c2c2c }));
                struct.position.set(x, 2, z);
                struct.rotation.set(seededRandom(), seededRandom(), seededRandom());
                scene.add(struct);
                levelObjects.push(struct);
                addSolidObject(x, z, 1.5, 3); // Rocher volcanique
            }
            // Cachette avec collision (bouton √† 41, 41)
            for (let i = 0; i < 6; i++) {
                let x, z;
                do {
                    x = 38 + (seededRandom() - 0.5) * 8;
                    z = 38 + (seededRandom() - 0.5) * 8;
                } while (Math.abs(x - 41) < 3 && Math.abs(z - 41) < 3); // √âviter le bouton
                const hidePillar = new THREE.Mesh(new THREE.BoxGeometry(3, 15, 3), new THREE.MeshLambertMaterial({ color: 0x0a0a0a }));
                hidePillar.position.set(x, 7.5, z);
                scene.add(hidePillar);
                levelObjects.push(hidePillar);
                addSolidObject(x, z, 2, 3); // Gros rocher
            }
        }

        // === NIVEAU 20: Sanctuaire Final (SP√âCIAL - Cl√© + Porte) ===
        function createFinalLevel() {
            // Structure centrale majestueuse (plateforme sur laquelle on peut marcher)
            const centralPlatform = new THREE.Mesh(new THREE.CylinderGeometry(15, 18, 2, 32), new THREE.MeshLambertMaterial({ color: 0x4a148c }));
            centralPlatform.position.set(0, 1, 0);
            scene.add(centralPlatform);
            levelObjects.push(centralPlatform);
            // Ajouter comme plateforme circulaire
            platforms.push({
                mesh: centralPlatform,
                minX: -15,
                maxX: 15,
                minZ: -15,
                maxZ: 15,
                y: 2,
                circular: true,
                radius: 15,
                blockSides: true // Bloquer les c√¥t√©s quand on est au sol
            });

            // Colonnes d'or avec collision
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const x = Math.cos(angle) * 20;
                const z = Math.sin(angle) * 20;
                const col = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 10, 12), new THREE.MeshLambertMaterial({ color: 0xffd700 }));
                col.position.set(x, 5, z);
                scene.add(col);
                levelObjects.push(col);
                addSolidObject(x, z, 0.8, 2); // Objet moyen
            }

            // === CL√â CACH√âE (pas de collision, on peut la ramasser) ===
            level20Key = new THREE.Group();
            // Corps de la cl√© (plus grosse et plus brillante)
            const keyMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.5 });
            const keyHandle = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.15, 8, 16), keyMaterial);
            keyHandle.rotation.x = Math.PI / 2;
            level20Key.add(keyHandle);
            const keyShaft = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.5, 0.15), keyMaterial);
            keyShaft.position.y = -0.75;
            level20Key.add(keyShaft);
            const keyTooth1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.15, 0.15), keyMaterial);
            keyTooth1.position.set(0.15, -1.3, 0);
            level20Key.add(keyTooth1);
            const keyTooth2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.15), keyMaterial);
            keyTooth2.position.set(0.1, -1.1, 0);
            level20Key.add(keyTooth2);
            // Position de la cl√© (√† c√¥t√© des rochers, visible mais partiellement cach√©e)
            level20Key.position.set(-27, 2.5, 28);
            level20Key.rotation.z = Math.PI / 6;
            scene.add(level20Key);
            levelObjects.push(level20Key);

            // Lumi√®re forte pour la cl√© (pour qu'elle brille)
            const keyLight = new THREE.PointLight(0xffd700, 1, 15);
            keyLight.position.set(-27, 4, 28);
            scene.add(keyLight);
            levelObjects.push(keyLight);

            // Rochers pr√®s de la cl√© (avec collision) - pas SUR la cl√©
            for (let i = 0; i < 5; i++) {
                const radius = 1.5 + seededRandom();
                let x, z;
                do {
                    x = -30 + (seededRandom() - 0.5) * 8;
                    z = 25 + (seededRandom() - 0.5) * 8;
                } while (Math.abs(x - (-27)) < 2.5 && Math.abs(z - 28) < 2.5); // √âviter la cl√©
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(radius), new THREE.MeshLambertMaterial({ color: 0x311b92 }));
                rock.position.set(x, 1, z);
                scene.add(rock);
                levelObjects.push(rock);
                addSolidObject(x, z, radius * 1.3, radius * 1.5); // Rocher - hitbox √©largie
            }

            // === FAUSSES GROSSES PIERRES (pour tromper le joueur) avec collision ===
            const fakeRockPositions = [
                { x: -35, z: -30 },
                { x: -25, z: 35 },
                { x: 30, z: 20 },
                { x: -15, z: -35 },
                { x: 40, z: 10 },
                { x: -40, z: 0 },
                { x: 15, z: -25 },
                { x: -10, z: 40 },
                { x: 25, z: -10 },
                { x: -35, z: 15 },
                { x: 5, z: 35 },
                { x: 38, z: -15 }
            ];

            fakeRockPositions.forEach(pos => {
                const fakeRock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(4 + seededRandom() * 2),
                    new THREE.MeshLambertMaterial({ color: 0x4a148c })
                );
                fakeRock.position.set(pos.x, 2.5 + seededRandom(), pos.z);
                fakeRock.scale.set(1.3 + seededRandom() * 0.4, 0.8 + seededRandom() * 0.4, 1.3 + seededRandom() * 0.4);
                fakeRock.rotation.y = seededRandom() * Math.PI;
                fakeRock.castShadow = true;
                scene.add(fakeRock);
                levelObjects.push(fakeRock);
                addSolidObject(pos.x, pos.z, 5, 6); // Grande pierre = 6 de haut
            });

            // === GROSSE PIERRE AVEC PORTE CACH√âE (la vraie!) ===
            level20Rock = new THREE.Group();
            // La grosse pierre
            const bigRock = new THREE.Mesh(new THREE.DodecahedronGeometry(5), new THREE.MeshLambertMaterial({ color: 0x4a148c }));
            bigRock.position.y = 3;
            bigRock.scale.set(1.5, 1, 1.5);
            level20Rock.add(bigRock);
            level20Rock.position.set(35, 0, -35);
            scene.add(level20Rock);
            levelObjects.push(level20Rock);
            // Collision grosse pierre (on garde la r√©f√©rence pour la supprimer plus tard)
            level20RockCollision = { x: 35, z: -35, radius: 6 };
            solidObjects.push(level20RockCollision);

            // === PORTE CACH√âE (dans la pierre) ===
            level20Door = new THREE.Group();
            // Cadre de la porte
            const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(3, 5, 0.5), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
            doorFrame.position.y = 2.5;
            level20Door.add(doorFrame);
            // Serrure
            const lock = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.3, 16), new THREE.MeshLambertMaterial({ color: 0xffd700 }));
            lock.rotation.x = Math.PI / 2;
            lock.position.set(0.8, 2, 0.3);
            level20Door.add(lock);
            // Poign√©e
            const handle = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshLambertMaterial({ color: 0xffd700 }));
            handle.position.set(0.8, 2.5, 0.3);
            level20Door.add(handle);
            level20Door.position.set(35, 0, -30);
            level20Door.visible = false; // Cach√©e au d√©but
            scene.add(level20Door);
            levelObjects.push(level20Door);

            // D√©coration: rochers mystiques avec collision
            for (let i = 0; i < 25; i++) {
                const radius = 1 + seededRandom();
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(radius), new THREE.MeshLambertMaterial({ color: 0x311b92 }));
                rock.position.set(x, 0.5, z);
                scene.add(rock);
                levelObjects.push(rock);
                addSolidObject(x, z, radius * 1.3, radius * 1.5); // Rocher - hitbox √©largie
            }

            // Arbres mystiques avec collision
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 5, 8), new THREE.MeshLambertMaterial({ color: 0x4a148c }));
                trunk.position.y = 2.5;
                tree.add(trunk);
                const leaves = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshLambertMaterial({ color: 0x7b1fa2 }));
                leaves.position.y = 6;
                tree.add(leaves);
                tree.position.set(x, 0, z);
                scene.add(tree);
                levelObjects.push(tree);
                addSolidObject(x, z, 0.5, 3); // Cactus/objet = 3 de haut
            }

            // Lumi√®re ambiante sp√©ciale
            const ambientPurple = new THREE.PointLight(0x9c27b0, 0.5, 100);
            ambientPurple.position.set(0, 20, 0);
            scene.add(ambientPurple);
            levelObjects.push(ambientPurple);
        }

        // ==========================================
        // === NOUVEAUX NIVEAUX CHAPITRE 1 ===
        // ==========================================

        function createClearingLevel() {
            // Clairi√®re ensoleill√©e avec arbres autour
            for (let i = 0; i < 40; i++) {
                const angle = seededRandom() * Math.PI * 2;
                const dist = 25 + seededRandom() * 20;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                createTree(x, z, 0.8 + seededRandom() * 0.4);
            }
            // Souches au centre
            for (let i = 0; i < 8; i++) {
                const x = (seededRandom() - 0.5) * 30;
                const z = (seededRandom() - 0.5) * 30;
                const stump = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 0.5, 8), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                stump.position.set(x, 0.25, z);
                scene.add(stump); levelObjects.push(stump);
                addSolidObject(x, z, 0.8, 0.5);
            }
            // Buissons
            for (let i = 0; i < 25; i++) {
                const x = (seededRandom() - 0.5) * 40;
                const z = (seededRandom() - 0.5) * 40;
                const r = 0.8 + seededRandom() * 0.6;
                const bush = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 8), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                bush.position.set(x, r * 0.5, z);
                scene.add(bush); levelObjects.push(bush);
                addSolidObject(x, z, r, r * 1.5); // Hauteur corrig√©e
            }
        }

        function createButterflyLevel() {
            // Pr√© aux papillons - beaucoup de fleurs color√©es
            const flowerColors = [0xff69b4, 0xffd700, 0xff6347, 0x87ceeb, 0xdda0dd, 0xf0e68c];
            for (let i = 0; i < 200; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const color = flowerColors[Math.floor(seededRandom() * flowerColors.length)];
                const height = 0.5 + seededRandom() * 0.5;
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, height), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                stem.position.set(x, height / 2, z);
                scene.add(stem); levelObjects.push(stem);
                const petals = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshLambertMaterial({ color }));
                petals.position.set(x, height + 0.1, z);
                scene.add(petals); levelObjects.push(petals);
            }
            // Quelques arbres
            for (let i = 0; i < 10; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                createTree(x, z, 0.8);
            }
        }

        function createValleyLevel() {
            // Vall√©e verte avec collines douces (simulated with mounds)
            // Position du bouton pour ce niveau
            const buttonX = nextButtonPos.x;
            const buttonZ = nextButtonPos.z;

            // Stocker les positions des collines pour √©viter de placer des objets dedans
            const moundPositions = [];
            for (let i = 0; i < 15; i++) {
                let x, z, r, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 80;
                    z = (seededRandom() - 0.5) * 80;
                    r = 5 + seededRandom() * 5;
                    attempts++;
                    // V√©rifier que la colline ne recouvre pas le bouton
                    const distToButton = Math.sqrt((x - buttonX) ** 2 + (z - buttonZ) ** 2);
                    if (distToButton > r + 2) break; // OK, assez loin du bouton
                } while (attempts < 50);
                const mound = new THREE.Mesh(new THREE.SphereGeometry(r, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: 0x4caf50 }));
                mound.position.set(x, 0, z);
                scene.add(mound); levelObjects.push(mound);
                moundPositions.push({ x, z, r });
                // Ajouter comme plateforme circulaire pour pouvoir marcher dessus
                platforms.push({
                    circular: true,
                    centerX: x,
                    centerZ: z,
                    radius: r,
                    y: r * 0.7, // Hauteur moyenne de la colline
                    isDome: true,
                    domeRadius: r
                });
            }

            // Fonction pour v√©rifier si une position est dans une colline
            function isInsideMound(x, z) {
                for (const m of moundPositions) {
                    const dx = x - m.x;
                    const dz = z - m.z;
                    if (Math.sqrt(dx * dx + dz * dz) < m.r) return true;
                }
                return false;
            }

            // Fonction pour v√©rifier si une position est trop proche du bouton
            function isTooCloseToButton(x, z, minDist = 3) {
                return Math.sqrt((x - buttonX) ** 2 + (z - buttonZ) ** 2) < minDist;
            }

            // Arbres (√©viter les collines ET le bouton)
            for (let i = 0; i < 30; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 70;
                    z = (seededRandom() - 0.5) * 70;
                    attempts++;
                } while ((isInsideMound(x, z) || isTooCloseToButton(x, z, 4)) && attempts < 30);
                if (!isInsideMound(x, z) && !isTooCloseToButton(x, z, 4)) {
                    createTree(x, z, 0.7 + seededRandom() * 0.3);
                }
            }
            // Buissons (√©viter les collines ET le bouton)
            for (let i = 0; i < 20; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 60;
                    z = (seededRandom() - 0.5) * 60;
                    attempts++;
                } while ((isInsideMound(x, z) || isTooCloseToButton(x, z, 3)) && attempts < 30);
                if (!isInsideMound(x, z) && !isTooCloseToButton(x, z, 3)) {
                    const r = 1 + seededRandom() * 0.5;
                    const bush = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 8), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
                    bush.position.set(x, r * 0.5, z);
                    scene.add(bush); levelObjects.push(bush);
                    addSolidObject(x, z, r, r * 1.5); // Hauteur corrig√©e
                }
            }
        }

        function createHillsLevel() {
            // Collines douces - m√™mes mounds plus grands
            // Position du bouton pour ce niveau
            const buttonX = nextButtonPos.x;
            const buttonZ = nextButtonPos.z;

            const moundPositions = [];
            for (let i = 0; i < 20; i++) {
                let x, z, r, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 90;
                    z = (seededRandom() - 0.5) * 90;
                    r = 4 + seededRandom() * 6;
                    attempts++;
                    const distToButton = Math.sqrt((x - buttonX) ** 2 + (z - buttonZ) ** 2);
                    if (distToButton > r + 2) break;
                } while (attempts < 50);

                const mound = new THREE.Mesh(new THREE.SphereGeometry(r, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: 0x81c784 }));
                mound.position.set(x, 0, z);
                scene.add(mound); levelObjects.push(mound);
                moundPositions.push({ x, z, r });
                platforms.push({
                    circular: true,
                    centerX: x,
                    centerZ: z,
                    radius: r,
                    y: r * 0.7,
                    isDome: true,
                    domeRadius: r
                });
            }

            function isInsideMound(x, z) {
                for (const m of moundPositions) {
                    const dx = x - m.x;
                    const dz = z - m.z;
                    if (Math.sqrt(dx * dx + dz * dz) < m.r) return true;
                }
                return false;
            }

            function isTooCloseToButton(x, z, minDist = 3) {
                return Math.sqrt((x - buttonX) ** 2 + (z - buttonZ) ** 2) < minDist;
            }

            // Pierres dispers√©es (√©viter les collines ET le bouton)
            for (let i = 0; i < 15; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 80;
                    z = (seededRandom() - 0.5) * 80;
                    attempts++;
                } while ((isInsideMound(x, z) || isTooCloseToButton(x, z, 3)) && attempts < 30);
                if (!isInsideMound(x, z) && !isTooCloseToButton(x, z, 3)) {
                    const r = 0.8 + seededRandom() * 1.2;
                    const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x9e9e9e }));
                    rock.position.set(x, r * 0.5, z);
                    rock.rotation.set(seededRandom(), seededRandom(), seededRandom());
                    scene.add(rock); levelObjects.push(rock);
                    addSolidObject(x, z, r, r * 1.5); // Hauteur = position Y + rayon
                }
            }
        }

        function createSecretGardenLevel() {
            // Jardin secret entour√© de haies
            // Murs de haies
            const hedgeMaterial = new THREE.MeshLambertMaterial({ color: 0x2e7d32 });
            for (let i = -40; i <= 40; i += 5) {
                if (Math.abs(i) > 5) { // Laisser une entr√©e
                    const hedge1 = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 2), hedgeMaterial);
                    hedge1.position.set(i, 1.5, -40);
                    scene.add(hedge1); levelObjects.push(hedge1);
                    addSolidObject(i, -40, 2, 3);

                    const hedge2 = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 2), hedgeMaterial);
                    hedge2.position.set(i, 1.5, 40);
                    scene.add(hedge2); levelObjects.push(hedge2);
                    addSolidObject(i, 40, 2, 3);
                }
            }
            // Haies lat√©rales (gauche et droite)
            for (let i = -40; i <= 40; i += 5) {
                if (Math.abs(i) > 5) {
                    const hedge3 = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 4), hedgeMaterial);
                    hedge3.position.set(-40, 1.5, i);
                    scene.add(hedge3); levelObjects.push(hedge3);
                    addSolidObject(-40, i, 2, 3);

                    const hedge4 = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 4), hedgeMaterial);
                    hedge4.position.set(40, 1.5, i);
                    scene.add(hedge4); levelObjects.push(hedge4);
                    addSolidObject(40, i, 2, 3);
                }
            }
            // Fleurs √† l'int√©rieur
            const flowerColors = [0xff6b6b, 0xfeca57, 0x5f27cd, 0x00d2d3];
            for (let i = 0; i < 80; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const color = flowerColors[Math.floor(seededRandom() * flowerColors.length)];
                const flower = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshLambertMaterial({ color }));
                flower.position.set(x, 0.3, z);
                scene.add(flower); levelObjects.push(flower);
            }
            // Fontaine l√©g√®rement d√©cal√©e du spawn (0,0) pour √©viter la t√©l√©portation
            const fountain = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.5, 1), new THREE.MeshLambertMaterial({ color: 0x90a4ae }));
            fountain.position.set(0, 0.5, 8);
            scene.add(fountain); levelObjects.push(fountain);
            addSolidObject(0, 8, 2.5, 1);
        }

        function createPlainLevel() {
            // Grande plaine avec peu d'obstacles
            // Hautes herbes dispers√©es
            for (let i = 0; i < 300; i++) {
                const x = (seededRandom() - 0.5) * 90;
                const z = (seededRandom() - 0.5) * 90;
                const height = 0.8 + seededRandom() * 1.2;
                const grass = new THREE.Mesh(new THREE.BoxGeometry(0.1, height, 0.1), new THREE.MeshLambertMaterial({ color: 0x7cb342 }));
                grass.position.set(x, height / 2, z);
                grass.rotation.y = seededRandom() * Math.PI;
                scene.add(grass); levelObjects.push(grass);
            }
            // Quelques rochers isol√©s
            for (let i = 0; i < 8; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 1 + seededRandom() * 1.5;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x757575 }));
                rock.position.set(x, r * 0.5, z);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(x, z, r, r * 1.5); // Hauteur corrig√©e
            }
        }

        function createGroveLevel() {
            // Bosquet d'arbres
            for (let i = 0; i < 60; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                createTree(x, z, 0.6 + seededRandom() * 0.4);
            }
            // Champignons
            for (let i = 0; i < 30; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const mushroom = new THREE.Group();
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.3), new THREE.MeshLambertMaterial({ color: 0xffefd5 }));
                stem.position.y = 0.15;
                mushroom.add(stem);
                const cap = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: 0xff6347 }));
                cap.position.y = 0.35;
                mushroom.add(cap);
                mushroom.position.set(x, 0, z);
                scene.add(mushroom); levelObjects.push(mushroom);
            }
        }

        function createFlowerFieldLevel() {
            // Champs de fleurs color√©es
            const flowerColors = [0xff1493, 0xffff00, 0xff4500, 0x9400d3, 0x00bfff, 0xff69b4];
            for (let i = 0; i < 500; i++) {
                const x = (seededRandom() - 0.5) * 90;
                const z = (seededRandom() - 0.5) * 90;
                const color = flowerColors[Math.floor(seededRandom() * flowerColors.length)];
                const h = 0.4 + seededRandom() * 0.4;
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, h), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                stem.position.set(x, h / 2, z);
                scene.add(stem); levelObjects.push(stem);
                const flower = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshLambertMaterial({ color }));
                flower.position.set(x, h + 0.1, z);
                scene.add(flower); levelObjects.push(flower);
            }
            // Quelques buissons
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 1.2 + seededRandom() * 0.8;
                const bush = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 8), new THREE.MeshLambertMaterial({ color: 0x2e8b57 }));
                bush.position.set(x, r * 0.5, z);
                scene.add(bush); levelObjects.push(bush);
                addSolidObject(x, z, r, r * 1.5); // Hauteur corrig√©e
            }
        }

        function createCastleLawnLevel() {
            // Pelouse du ch√¢teau avec structure au fond
            // Murs du ch√¢teau (au fond)
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
            const wall = new THREE.Mesh(new THREE.BoxGeometry(30, 8, 2), wallMaterial);
            wall.position.set(0, 4, -40);
            scene.add(wall); levelObjects.push(wall);
            // Collision rectangulaire pour le mur
            addSolidWall(0, -40, 30, 2, 8);

            // Tours
            for (let i = -1; i <= 1; i += 2) {
                const tower = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 12, 8), wallMaterial);
                tower.position.set(i * 18, 6, -40);
                scene.add(tower); levelObjects.push(tower);
                addSolidObject(i * 18, -40, 3, 12);
            }

            // Haies g√©om√©triques
            for (let i = -30; i <= 30; i += 15) {
                const hedge = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 2), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                hedge.position.set(i, 1, 20);
                scene.add(hedge); levelObjects.push(hedge);
                addSolidObject(i, 20, 4, 2);
            }

            // Fontaine (d√©cal√©e du spawn pour √©viter collision)
            const fountain = new THREE.Mesh(new THREE.CylinderGeometry(3, 3.5, 1.5), new THREE.MeshLambertMaterial({ color: 0xb0c4de }));
            fountain.position.set(0, 0.75, -15);
            scene.add(fountain); levelObjects.push(fountain);
            addSolidObject(0, -15, 3.5, 1.5);
        }

        function createPastureLevel() {
            // P√¢turage avec cl√¥tures et moutons (cubes blancs)
            // Cl√¥tures
            const fenceMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            for (let i = -40; i <= 40; i += 10) {
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.5), fenceMaterial);
                post.position.set(i, 0.75, -35);
                scene.add(post); levelObjects.push(post);
                addSolidObject(i, -35, 0.15, 1.5);
            }
            // Moutons (blocs blancs)
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const sheep = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 1.5), new THREE.MeshLambertMaterial({ color: 0xffffff }));
                sheep.position.set(x, 0.4, z);
                scene.add(sheep); levelObjects.push(sheep);
                addSolidObject(x, z, 0.75, 0.8);
            }
            // Herbes hautes
            for (let i = 0; i < 200; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const h = 0.5 + seededRandom() * 0.5;
                const grass = new THREE.Mesh(new THREE.BoxGeometry(0.1, h, 0.1), new THREE.MeshLambertMaterial({ color: 0x7cb342 }));
                grass.position.set(x, h / 2, z);
                scene.add(grass); levelObjects.push(grass);
            }
        }

        function createOrchardLevel() {
            // Verger avec arbres fruitiers en rang√©es
            for (let row = -35; row <= 35; row += 10) {
                for (let col = -35; col <= 35; col += 10) {
                    const tree = new THREE.Group();
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 3), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                    trunk.position.y = 1.5;
                    tree.add(trunk);
                    const leaves = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                    leaves.position.y = 4;
                    tree.add(leaves);
                    // Fruits
                    for (let f = 0; f < 5; f++) {
                        const fruit = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshLambertMaterial({ color: 0xff0000 }));
                        fruit.position.set((seededRandom() - 0.5) * 2, 3.5 + seededRandom(), (seededRandom() - 0.5) * 2);
                        tree.add(fruit);
                    }
                    // Position de l'arbre avec d√©calage al√©atoire
                    const treeX = col + seededRandom() * 2;
                    const treeZ = row + seededRandom() * 2;
                    tree.position.set(treeX, 0, treeZ);
                    scene.add(tree); levelObjects.push(tree);
                    // Collision sur tout l'arbre (tronc + feuilles)
                    addSolidObject(treeX, treeZ, 2, 6);
                }
            }
        }

        function createZenLevel() {
            // Jardin zen japonais
            // Sable ratiss√© (cercles)
            const sandMaterial = new THREE.MeshLambertMaterial({ color: 0xf5deb3 });
            for (let i = 0; i < 8; i++) {
                const r = 3 + i * 3;
                const ring = new THREE.Mesh(new THREE.TorusGeometry(r, 0.1, 4, 32), sandMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.05;
                scene.add(ring); levelObjects.push(ring);
            }
            // Pierres zen
            const stonePositions = [[-10, -10], [15, 5], [-5, 20], [20, -15], [-20, 10]];
            stonePositions.forEach(([x, z]) => {
                const r = 1.5 + seededRandom();
                const stone = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 6), new THREE.MeshLambertMaterial({ color: 0x505050 }));
                stone.scale.y = 0.5;
                stone.position.set(x, r * 0.25, z);
                scene.add(stone); levelObjects.push(stone);
                addSolidObject(x, z, r, r * 0.5);
            });
            // Lanternes
            for (let i = 0; i < 4; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const lantern = new THREE.Group();
                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 0.3), new THREE.MeshLambertMaterial({ color: 0x808080 }));
                base.position.y = 0.15;
                lantern.add(base);
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.5), new THREE.MeshLambertMaterial({ color: 0x808080 }));
                pillar.position.y = 1;
                lantern.add(pillar);
                const top = new THREE.Mesh(new THREE.ConeGeometry(0.5, 0.4, 4), new THREE.MeshLambertMaterial({ color: 0x808080 }));
                top.position.y = 2;
                lantern.add(top);
                lantern.position.set(x, 0, z);
                scene.add(lantern); levelObjects.push(lantern);
                addSolidObject(x, z, 0.5, 2.2);
            }
        }

        function createMistyMeadowLevel() {
            // Prairie brumeuse - comme meadow mais avec plus de brouillard (d√©j√† g√©r√© dans config)
            // Arbres fantomatiques
            for (let i = 0; i < 25; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 5), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                trunk.position.y = 2.5;
                tree.add(trunk);
                const leaves = new THREE.Mesh(new THREE.SphereGeometry(2.5, 8, 8), new THREE.MeshLambertMaterial({ color: 0x558b2f, transparent: true, opacity: 0.8 }));
                leaves.position.y = 5.5;
                tree.add(leaves);
                tree.position.set(x, 0, z);
                scene.add(tree); levelObjects.push(tree);
                addSolidObject(x, z, 0.5, 6);
            }
            // Herbes
            for (let i = 0; i < 400; i++) {
                const x = (seededRandom() - 0.5) * 90;
                const z = (seededRandom() - 0.5) * 90;
                const h = 1 + seededRandom() * 1.5;
                const grass = new THREE.Mesh(new THREE.BoxGeometry(0.1, h, 0.1), new THREE.MeshLambertMaterial({ color: 0x7cb342 }));
                grass.position.set(x, h / 2, z);
                scene.add(grass); levelObjects.push(grass);
            }
        }

        function createMagicClearingLevel() {
            // Clairi√®re magique avec lueurs
            createClearingLevel();
            // Ajouter des lumi√®res color√©es
            const lightColors = [0xff69b4, 0x00ffff, 0xffd700, 0x9400d3];
            for (let i = 0; i < 10; i++) {
                const x = (seededRandom() - 0.5) * 40;
                const z = (seededRandom() - 0.5) * 40;
                const color = lightColors[Math.floor(seededRandom() * lightColors.length)];
                const light = new THREE.PointLight(color, 0.5, 10);
                light.position.set(x, 2, z);
                scene.add(light); levelObjects.push(light);
                // Orbe visible
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color }));
                orb.position.set(x, 2, z);
                scene.add(orb); levelObjects.push(orb);
            }
        }

        function createFairyValleyLevel() {
            createValleyLevel();
            // Ajouter des champignons lumineux
            for (let i = 0; i < 30; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const mushroom = new THREE.Group();
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.5), new THREE.MeshLambertMaterial({ color: 0xffefd5 }));
                stem.position.y = 0.25;
                mushroom.add(stem);
                const colors = [0xff69b4, 0x00bfff, 0xdda0dd];
                const cap = new THREE.Mesh(new THREE.SphereGeometry(0.35, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: colors[Math.floor(seededRandom() * 3)], emissive: 0x444444 }));
                cap.position.y = 0.55;
                mushroom.add(cap);
                mushroom.position.set(x, 0, z);
                scene.add(mushroom); levelObjects.push(mushroom);
            }
        }

        function createEnchantedLevel() {
            // For√™t enchant√©e
            for (let i = 0; i < 40; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 6), new THREE.MeshLambertMaterial({ color: 0x4a148c }));
                trunk.position.y = 3;
                tree.add(trunk);
                const leaves = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), new THREE.MeshLambertMaterial({ color: 0x7b1fa2 }));
                leaves.position.y = 7;
                tree.add(leaves);
                tree.position.set(x, 0, z);
                scene.add(tree); levelObjects.push(tree);
                addSolidObject(x, z, 0.5, 6);
            }
            // Particules magiques (orbes)
            for (let i = 0; i < 20; i++) {
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                orb.position.set((seededRandom() - 0.5) * 60, 1 + seededRandom() * 3, (seededRandom() - 0.5) * 60);
                scene.add(orb); levelObjects.push(orb);
            }
        }

        function createParadiseLevel() {
            // Jardin du paradis - tr√®s color√©
            createGardenLevel();
            // Arc-en-ciel (torus arc)
            const rainbowColors = [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3];
            for (let i = 0; i < rainbowColors.length; i++) {
                const arc = new THREE.Mesh(
                    new THREE.TorusGeometry(25 + i * 2, 0.5, 8, 32, Math.PI),
                    new THREE.MeshBasicMaterial({ color: rainbowColors[i] })
                );
                arc.rotation.x = Math.PI;
                arc.rotation.z = Math.PI / 2;
                arc.position.set(0, 0, 0);
                scene.add(arc); levelObjects.push(arc);
            }
            // Plus de fleurs
            const colors = [0xff1493, 0x00ff7f, 0xffd700, 0x00bfff];
            for (let i = 0; i < 100; i++) {
                const flower = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshLambertMaterial({ color: colors[Math.floor(seededRandom() * 4)] }));
                flower.position.set((seededRandom() - 0.5) * 80, 0.3, (seededRandom() - 0.5) * 80);
                scene.add(flower); levelObjects.push(flower);
            }
        }

        function createEternalLevel() {
            // Prairie √©ternelle - vaste et paisible
            createPlainLevel();
            // Monolithes anciens
            for (let i = 0; i < 5; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const h = 4 + seededRandom() * 4;
                const monolith = new THREE.Mesh(new THREE.BoxGeometry(2, h, 1), new THREE.MeshLambertMaterial({ color: 0x607d8b }));
                monolith.position.set(x, h / 2, z);
                scene.add(monolith); levelObjects.push(monolith);
                addSolidObject(x, z, 1, h);
            }
        }

        // ==========================================
        // === NOUVEAUX NIVEAUX CHAPITRE 2 ===
        // ==========================================

        function createSavannaLevel() {
            // Savane africaine avec acacias
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                // Acacia
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 5), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                trunk.position.set(x, 2.5, z);
                scene.add(trunk); levelObjects.push(trunk);
                const crown = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 1, 16), new THREE.MeshLambertMaterial({ color: 0x556b2f }));
                crown.position.set(x, 5.5, z);
                scene.add(crown); levelObjects.push(crown);
                addSolidObject(x, z, 0.5, 6);
            }
            // Hautes herbes jaunes
            for (let i = 0; i < 300; i++) {
                const x = (seededRandom() - 0.5) * 90;
                const z = (seededRandom() - 0.5) * 90;
                const h = 0.8 + seededRandom() * 1.2;
                const grass = new THREE.Mesh(new THREE.BoxGeometry(0.1, h, 0.1), new THREE.MeshLambertMaterial({ color: 0xdaa520 }));
                grass.position.set(x, h / 2, z);
                scene.add(grass); levelObjects.push(grass);
            }
            // Rochers
            for (let i = 0; i < 10; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 1 + seededRandom() * 2;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0xa0522d }));
                rock.position.set(x, r * 0.4, z);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(x, z, r, r * 1.4);
            }
        }

        function createCoastLevel() {
            // C√¥te sauvage avec falaises
            // Falaises (boxes)
            for (let i = -45; i <= 45; i += 8) {
                const h = 3 + seededRandom() * 4;
                const cliff = new THREE.Mesh(new THREE.BoxGeometry(6, h, 4), new THREE.MeshLambertMaterial({ color: 0x8d6e63 }));
                cliff.position.set(i, h / 2, 40);
                scene.add(cliff); levelObjects.push(cliff);
                addSolidObject(i, 40, 3, h);
            }
            // Rochers sur la plage
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 60 - 10;
                const r = 0.8 + seededRandom() * 1.5;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x607d8b }));
                rock.position.set(x, r * 0.4, z);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(x, z, r, r * 1.4);
            }
        }

        function createDunesLevel() {
            // Dunes de sable
            // Position du bouton pour ce niveau
            const buttonX = nextButtonPos.x;
            const buttonZ = nextButtonPos.z;

            const dunePositions = [];
            for (let i = 0; i < 25; i++) {
                let x, z, r, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 90;
                    z = (seededRandom() - 0.5) * 90;
                    r = 5 + seededRandom() * 8;
                    attempts++;
                    const distToButton = Math.sqrt((x - buttonX) ** 2 + (z - buttonZ) ** 2);
                    if (distToButton > r + 2) break;
                } while (attempts < 50);

                const dune = new THREE.Mesh(new THREE.SphereGeometry(r, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: 0xffd699 }));
                dune.position.set(x, 0, z);
                scene.add(dune); levelObjects.push(dune);
                dunePositions.push({ x, z, r });
                platforms.push({
                    circular: true,
                    centerX: x,
                    centerZ: z,
                    radius: r,
                    y: r * 0.7,
                    isDome: true,
                    domeRadius: r
                });
            }

            function isInsideDune(x, z) {
                for (const d of dunePositions) {
                    const dx = x - d.x;
                    const dz = z - d.z;
                    if (Math.sqrt(dx * dx + dz * dz) < d.r) return true;
                }
                return false;
            }

            function isTooCloseToButton(x, z, minDist = 3) {
                return Math.sqrt((x - buttonX) ** 2 + (z - buttonZ) ** 2) < minDist;
            }

            // Cactus rares (√©viter les dunes ET le bouton)
            for (let i = 0; i < 8; i++) {
                let x, z, attempts = 0;
                do {
                    x = (seededRandom() - 0.5) * 80;
                    z = (seededRandom() - 0.5) * 80;
                    attempts++;
                } while ((isInsideDune(x, z) || isTooCloseToButton(x, z, 3)) && attempts < 30);
                if (!isInsideDune(x, z) && !isTooCloseToButton(x, z, 3)) {
                    createCactus(x, z);
                }
            }
        }

        function createAmazonLevel() {
            // For√™t amazonienne dense
            createJungleLevel();
            // Plus de v√©g√©tation au sol
            for (let i = 0; i < 100; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 0.5 + seededRandom() * 0.8;
                const fern = new THREE.Mesh(new THREE.ConeGeometry(r, r * 2, 4), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                fern.position.set(x, r, z);
                scene.add(fern); levelObjects.push(fern);
            }
        }

        function createOasisLevel() {
            // Oasis dans le d√©sert
            createDesertLevel();
            // Lac central
            const lake = new THREE.Mesh(new THREE.CircleGeometry(10, 32), new THREE.MeshLambertMaterial({ color: 0x4169e1, transparent: true, opacity: 0.8 }));
            lake.rotation.x = -Math.PI / 2;
            lake.position.set(0, 0.01, 0);
            scene.add(lake); levelObjects.push(lake);
            // Palmiers autour
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const x = Math.cos(angle) * 12;
                const z = Math.sin(angle) * 12;
                createPalm(x, z);
            }
        }

        function createMangroveLevel() {
            // Mangrove avec racines
            createSwampLevel();
            // Plus d'arbres avec racines visibles
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const tree = new THREE.Group();
                // Racines
                for (let r = 0; r < 4; r++) {
                    const angle = (r / 4) * Math.PI * 2;
                    const root = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 2), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                    root.position.set(Math.cos(angle) * 0.5, 1, Math.sin(angle) * 0.5);
                    root.rotation.z = angle * 0.3;
                    tree.add(root);
                }
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 3), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                trunk.position.y = 2.5;
                tree.add(trunk);
                const leaves = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 8), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
                leaves.position.y = 4.5;
                tree.add(leaves);
                tree.position.set(x, 0, z);
                scene.add(tree); levelObjects.push(tree);
                addSolidObject(x, z, 0.5, 5);
            }
        }

        function createSteppeLevel() {
            // Steppe vent√©e
            createPlainLevel();
            // Touffes d'herbes
            for (let i = 0; i < 100; i++) {
                const x = (seededRandom() - 0.5) * 90;
                const z = (seededRandom() - 0.5) * 90;
                const tuft = new THREE.Group();
                for (let g = 0; g < 8; g++) {
                    const h = 0.5 + seededRandom() * 0.8;
                    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, h, 0.05), new THREE.MeshLambertMaterial({ color: 0xbdb76b }));
                    blade.position.set((seededRandom() - 0.5) * 0.3, h / 2, (seededRandom() - 0.5) * 0.3);
                    blade.rotation.z = (seededRandom() - 0.5) * 0.3;
                    tuft.add(blade);
                }
                tuft.position.set(x, 0, z);
                scene.add(tuft); levelObjects.push(tuft);
            }
        }

        function createPineForestLevel() {
            // For√™t de pins
            for (let i = 0; i < 50; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const pine = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 6), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                trunk.position.y = 3;
                pine.add(trunk);
                // Niveaux de feuillage
                for (let lvl = 0; lvl < 4; lvl++) {
                    const cone = new THREE.Mesh(new THREE.ConeGeometry(2 - lvl * 0.3, 2), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
                    cone.position.y = 5 + lvl * 1.2;
                    pine.add(cone);
                }
                pine.position.set(x, 0, z);
                scene.add(pine); levelObjects.push(pine);
                addSolidObject(x, z, 0.4, 8);
            }
        }

        function createStormyShoreLevel() {
            // Rivage orageux
            createCoastLevel();
            // Vagues (cylindres bleus)
            for (let i = 0; i < 15; i++) {
                const wave = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 0.5, 16, 1, false, 0, Math.PI), new THREE.MeshLambertMaterial({ color: 0x1e90ff, transparent: true, opacity: 0.7 }));
                wave.rotation.x = Math.PI / 2;
                wave.position.set((seededRandom() - 0.5) * 80, 0.25, -35 + seededRandom() * 10);
                scene.add(wave); levelObjects.push(wave);
            }
        }

        function createIceDesertLevel() {
            // D√©sert de glace
            createSnowLevel();
            // Blocs de glace
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const w = 2 + seededRandom() * 3;
                const h = 2 + seededRandom() * 3;
                const ice = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshLambertMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.8 }));
                ice.position.set(x, h / 2, z);
                scene.add(ice); levelObjects.push(ice);
                addSolidObject(x, z, w / 2, h);
            }
        }

        function createBayouLevel() {
            // Bayou sinistre
            createSwampLevel();
            // Arbres avec mousse
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 6), new THREE.MeshLambertMaterial({ color: 0x3e2723 }));
                trunk.position.y = 3;
                tree.add(trunk);
                // Mousse pendante
                for (let m = 0; m < 5; m++) {
                    const moss = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2 + seededRandom()), new THREE.MeshLambertMaterial({ color: 0x9e9d24 }));
                    moss.position.set((seededRandom() - 0.5) * 2, 5 - seededRandom(), (seededRandom() - 0.5) * 2);
                    tree.add(moss);
                }
                tree.position.set(x, 0, z);
                scene.add(tree); levelObjects.push(tree);
                addSolidObject(x, z, 0.5, 6);
            }
        }

        function createPetrifiedLevel() {
            // For√™t p√©trifi√©e
            for (let i = 0; i < 40; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const h = 3 + seededRandom() * 4;
                const tree = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, h), new THREE.MeshLambertMaterial({ color: 0x808080 }));
                tree.position.set(x, h / 2, z);
                scene.add(tree); levelObjects.push(tree);
                addSolidObject(x, z, 0.5, h);
            }
            // Fragments au sol
            for (let i = 0; i < 30; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const fragment = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5 + seededRandom() * 0.5), new THREE.MeshLambertMaterial({ color: 0x696969 }));
                fragment.position.set(x, 0.3, z);
                fragment.rotation.set(seededRandom(), seededRandom(), seededRandom());
                scene.add(fragment); levelObjects.push(fragment);
            }
        }

        function createWastelandLevel() {
            // Terres d√©sol√©es
            // Sol craquel√© (lignes)
            for (let i = 0; i < 50; i++) {
                const x = (seededRandom() - 0.5) * 90;
                const z = (seededRandom() - 0.5) * 90;
                const crack = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 3 + seededRandom() * 5), new THREE.MeshLambertMaterial({ color: 0x3e2723 }));
                crack.position.set(x, 0.03, z);
                crack.rotation.y = seededRandom() * Math.PI;
                scene.add(crack); levelObjects.push(crack);
            }
            // Ossements (spheres blanches)
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const bone = new THREE.Mesh(new THREE.CapsuleGeometry(0.15, 0.8), new THREE.MeshLambertMaterial({ color: 0xf5f5dc }));
                bone.position.set(x, 0.15, z);
                bone.rotation.z = Math.PI / 2;
                bone.rotation.y = seededRandom() * Math.PI;
                scene.add(bone); levelObjects.push(bone);
            }
            // Rochers
            for (let i = 0; i < 12; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 1 + seededRandom() * 2;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                rock.position.set(x, r * 0.4, z);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(x, z, r, r * 1.4);
            }
        }

        // ==========================================
        // === NOUVEAUX NIVEAUX CHAPITRE 3 ===
        // ==========================================

        function createCastleRuinsLevel() {
            // Ch√¢teau en ruines
            // Murs effondr√©s
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x5d5d5d });
            for (let i = 0; i < 8; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const w = 5 + seededRandom() * 5;
                const h = 2 + seededRandom() * 4;
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, 1), wallMaterial);
                wall.position.set(x, h / 2, z);
                wall.rotation.y = seededRandom() * Math.PI;
                scene.add(wall); levelObjects.push(wall);
                addSolidObject(x, z, w / 2, h);
            }
            // Tours partiellement d√©truites
            for (let i = 0; i < 4; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const h = 5 + seededRandom() * 5;
                const tower = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.5, h, 8, 1, true), wallMaterial);
                tower.position.set(x, h / 2, z);
                scene.add(tower); levelObjects.push(tower);
                addSolidObject(x, z, 2.5, h);
            }
            // D√©bris
            for (let i = 0; i < 40; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 0.3 + seededRandom() * 0.5;
                const debris = new THREE.Mesh(new THREE.BoxGeometry(r, r, r), wallMaterial);
                debris.position.set(x, r / 2, z);
                debris.rotation.set(seededRandom(), seededRandom(), seededRandom());
                scene.add(debris); levelObjects.push(debris);
            }
        }

        function createLostCityLevel() {
            // Cit√© perdue
            // B√¢timents en ruines
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const w = 4 + seededRandom() * 4;
                const h = 3 + seededRandom() * 5;
                const building = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshLambertMaterial({ color: 0x455a64 }));
                building.position.set(x, h / 2, z);
                scene.add(building); levelObjects.push(building);
                addSolidObject(x, z, w / 2 + 0.5, h);
            }
            // V√©g√©tation envahissante
            for (let i = 0; i < 30; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const vine = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 3 + seededRandom() * 3), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                vine.position.set(x, 2, z);
                scene.add(vine); levelObjects.push(vine);
            }
        }

        function createMonasteryLevel() {
            // Monast√®re ancien
            // B√¢timent central
            const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0x795548 });
            const mainBuilding = new THREE.Mesh(new THREE.BoxGeometry(20, 8, 15), stoneMaterial);
            mainBuilding.position.set(0, 4, -20);
            scene.add(mainBuilding); levelObjects.push(mainBuilding);
            addSolidObject(0, -20, 10, 8);
            // Clocher
            const tower = new THREE.Mesh(new THREE.BoxGeometry(5, 15, 5), stoneMaterial);
            tower.position.set(0, 7.5, -30);
            scene.add(tower); levelObjects.push(tower);
            addSolidObject(0, -30, 2.5, 15);
            // Jardins
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 40;
                const z = 10 + seededRandom() * 30;
                const bush = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
                bush.position.set(x, 0.5, z);
                scene.add(bush); levelObjects.push(bush);
                addSolidObject(x, z, 1, 1.5); // Hauteur corrig√©e
            }
        }

        function createPalaceLevel() {
            // Palais effondr√©
            // Colonnes bris√©es
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const h = 2 + seededRandom() * 4;
                const column = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, h), new THREE.MeshLambertMaterial({ color: 0xbcaaa4 }));
                column.position.set(x, h / 2, z);
                scene.add(column); levelObjects.push(column);
                addSolidObject(x, z, 0.6, h);
            }
            // Blocs de marbre
            for (let i = 0; i < 25; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const s = 1 + seededRandom() * 2;
                const block = new THREE.Mesh(new THREE.BoxGeometry(s, s, s), new THREE.MeshLambertMaterial({ color: 0xe0e0e0 }));
                block.position.set(x, s / 2, z);
                block.rotation.y = seededRandom() * Math.PI;
                scene.add(block); levelObjects.push(block);
                addSolidObject(x, z, s / 2, s);
            }
        }

        function createTowerLevel() {
            // Tour abandonn√©e
            // Tour centrale massive
            const towerMaterial = new THREE.MeshLambertMaterial({ color: 0x546e7a });
            const mainTower = new THREE.Mesh(new THREE.CylinderGeometry(8, 10, 20, 8), towerMaterial);
            mainTower.position.set(0, 10, 0);
            scene.add(mainTower); levelObjects.push(mainTower);
            addSolidObject(0, 0, 10, 20);
            // Petites tours autour
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const x = Math.cos(angle) * 25;
                const z = Math.sin(angle) * 25;
                const h = 8 + seededRandom() * 4;
                const tower = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.5, h, 6), towerMaterial);
                tower.position.set(x, h / 2, z);
                scene.add(tower); levelObjects.push(tower);
                addSolidObject(x, z, 2.5, h);
            }
            // D√©bris
            for (let i = 0; i < 30; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 0.5 + seededRandom() * 1;
                const debris = new THREE.Mesh(new THREE.DodecahedronGeometry(r), towerMaterial);
                debris.position.set(x, r * 0.4, z);
                scene.add(debris); levelObjects.push(debris);
                addSolidObject(x, z, r, r * 1.4);
            }
        }

        function createFortressLevel() {
            // Forteresse d√©truite
            // Murs √©pais
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x37474f });
            const walls = [
                { x: 0, z: -35, w: 60, h: 6 },
                { x: 0, z: 35, w: 60, h: 4 },
                { x: -35, z: 0, w: 6, h: 5, roty: Math.PI / 2 },
                { x: 35, z: 0, w: 6, h: 3, roty: Math.PI / 2 }
            ];
            walls.forEach(w => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w.w || 60, w.h, 3), wallMaterial);
                wall.position.set(w.x, w.h / 2, w.z);
                if (w.roty) wall.rotation.y = w.roty;
                scene.add(wall); levelObjects.push(wall);
                addSolidObject(w.x, w.z, 30, w.h);
            });
            // Tours d'angle
            const corners = [[-35, -35], [35, -35], [-35, 35], [35, 35]];
            corners.forEach(([x, z]) => {
                const h = 8 + seededRandom() * 4;
                const tower = new THREE.Mesh(new THREE.CylinderGeometry(3, 3.5, h, 6), wallMaterial);
                tower.position.set(x, h / 2, z);
                scene.add(tower); levelObjects.push(tower);
                addSolidObject(x, z, 3.5, h);
            });
        }

        function createColiseumLevel() {
            // Colis√©e romain
            // Mur elliptique
            const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0xd4b896 });
            for (let i = 0; i < 36; i++) {
                const angle = (i / 36) * Math.PI * 2;
                const x = Math.cos(angle) * 35;
                const z = Math.sin(angle) * 25;
                const h = 6 + seededRandom() * 2;
                const section = new THREE.Mesh(new THREE.BoxGeometry(6, h, 2), stoneMaterial);
                section.position.set(x, h / 2, z);
                section.rotation.y = angle + Math.PI / 2;
                scene.add(section); levelObjects.push(section);
                addSolidObject(x, z, 3, h);
            }
            // Colonnes int√©rieures
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const x = Math.cos(angle) * 20;
                const z = Math.sin(angle) * 15;
                const h = 4 + seededRandom() * 2;
                const column = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, h), stoneMaterial);
                column.position.set(x, h / 2, z);
                scene.add(column); levelObjects.push(column);
                addSolidObject(x, z, 0.6, h);
            }
        }

        function createPyramidLevel() {
            // Pyramide maya
            // Pyramide √† degr√©s
            const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0x8d6e63 });
            for (let i = 0; i < 6; i++) {
                const size = 20 - i * 3;
                const h = 3;
                const step = new THREE.Mesh(new THREE.BoxGeometry(size, h, size), stoneMaterial);
                step.position.set(0, i * h + h / 2, 0);
                scene.add(step); levelObjects.push(step);
            }
            // Collision pour la pyramide
            addSolidObject(0, 0, 10, 18);
            // St√®les autour
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * 30;
                const z = Math.sin(angle) * 30;
                const stele = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 0.5), stoneMaterial);
                stele.position.set(x, 1.5, z);
                stele.rotation.y = angle;
                scene.add(stele); levelObjects.push(stele);
                addSolidObject(x, z, 0.75, 3);
            }
        }

        function createCathedralLevel() {
            // Cath√©drale gothique
            const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0x424242 });
            // Corps principal
            const main = new THREE.Mesh(new THREE.BoxGeometry(15, 15, 40), stoneMaterial);
            main.position.set(0, 7.5, 0);
            scene.add(main); levelObjects.push(main);
            addSolidObject(0, 0, 8, 15);
            // Tours
            for (let i = -1; i <= 1; i += 2) {
                const tower = new THREE.Mesh(new THREE.BoxGeometry(5, 25, 5), stoneMaterial);
                tower.position.set(i * 10, 12.5, -18);
                scene.add(tower); levelObjects.push(tower);
                addSolidObject(i * 10, -18, 2.5, 25);
                // Fl√®che
                const spire = new THREE.Mesh(new THREE.ConeGeometry(2, 8), stoneMaterial);
                spire.position.set(i * 10, 29, -18);
                scene.add(spire); levelObjects.push(spire);
            }
            // Vitraux (rectangles color√©s)
            const colors = [0xff0000, 0x0000ff, 0xffff00, 0x00ff00];
            for (let i = 0; i < 6; i++) {
                const window = new THREE.Mesh(new THREE.PlaneGeometry(2, 4), new THREE.MeshBasicMaterial({ color: colors[i % 4], side: THREE.DoubleSide }));
                window.position.set(7.51, 8, -15 + i * 6);
                window.rotation.y = Math.PI / 2;
                scene.add(window); levelObjects.push(window);
            }
        }

        function createCitadelLevel() {
            // Citadelle m√©di√©vale
            createFortressLevel();
            // Ajouter donjon central
            const donjon = new THREE.Mesh(new THREE.BoxGeometry(12, 15, 12), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
            donjon.position.set(0, 7.5, 0);
            scene.add(donjon); levelObjects.push(donjon);
            addSolidObject(0, 0, 6, 15);
        }

        function createAmphitheaterLevel() {
            // Amphith√©√¢tre grec
            const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0xefebe9 });
            // Gradins en demi-cercle
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 20; col++) {
                    const angle = (col / 20) * Math.PI - Math.PI / 2;
                    const r = 15 + row * 4;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r + 20;
                    const gradin = new THREE.Mesh(new THREE.BoxGeometry(3, 1 + row * 0.5, 2), stoneMaterial);
                    gradin.position.set(x, (1 + row * 0.5) / 2, z);
                    gradin.rotation.y = angle + Math.PI / 2;
                    scene.add(gradin); levelObjects.push(gradin);
                    addSolidObject(x, z, 1.5, 1 + row * 0.5);
                }
            }
            // Sc√®ne
            const stage = new THREE.Mesh(new THREE.BoxGeometry(20, 1, 10), stoneMaterial);
            stage.position.set(0, 0.5, -5);
            scene.add(stage); levelObjects.push(stage);
            platforms.push({ x: 0, z: -5, radius: 10, height: 1 });
        }

        function createPagodaLevel() {
            // Pagode asiatique
            const woodMaterial = new THREE.MeshLambertMaterial({ color: 0x8b0000 });
            // √âtages de la pagode
            for (let i = 0; i < 5; i++) {
                const size = 10 - i * 1.5;
                const floor = new THREE.Mesh(new THREE.BoxGeometry(size, 2, size), woodMaterial);
                floor.position.set(0, i * 3 + 1, 0);
                scene.add(floor); levelObjects.push(floor);
                // Toits
                const roof = new THREE.Mesh(new THREE.ConeGeometry(size * 0.8, 1, 4), new THREE.MeshLambertMaterial({ color: 0x2f4f4f }));
                roof.position.set(0, i * 3 + 2.5, 0);
                roof.rotation.y = Math.PI / 4;
                scene.add(roof); levelObjects.push(roof);
            }
            addSolidObject(0, 0, 5, 15);
            // Bambous autour
            for (let i = 0; i < 40; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                if (Math.abs(x) > 10 || Math.abs(z) > 10) {
                    const h = 4 + seededRandom() * 4;
                    const bamboo = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, h), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                    bamboo.position.set(x, h / 2, z);
                    scene.add(bamboo); levelObjects.push(bamboo);
                }
            }
        }

        function createZigguratLevel() {
            // Ziggourat babylonienne
            const brickMaterial = new THREE.MeshLambertMaterial({ color: 0xbcaaa4 });
            for (let i = 0; i < 7; i++) {
                const size = 25 - i * 3;
                const step = new THREE.Mesh(new THREE.BoxGeometry(size, 2, size), brickMaterial);
                step.position.set(0, i * 2 + 1, 0);
                scene.add(step); levelObjects.push(step);
            }
            addSolidObject(0, 0, 12.5, 14);
            // Statues de lions
            for (let i = -1; i <= 1; i += 2) {
                const lion = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 3), new THREE.MeshLambertMaterial({ color: 0xdaa520 }));
                lion.position.set(i * 15, 0.75, -20);
                scene.add(lion); levelObjects.push(lion);
                addSolidObject(i * 15, -20, 1.5, 1.5);
            }
        }

        function createAztecLevel() {
            // Temple azt√®que
            createPyramidLevel();
            // Ajouter autel au sommet
            const altar = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 4), new THREE.MeshLambertMaterial({ color: 0x8b0000 }));
            altar.position.set(0, 18.5, 0);
            scene.add(altar); levelObjects.push(altar);
            // Torches
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                const x = Math.cos(angle) * 25;
                const z = Math.sin(angle) * 25;
                const torch = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 3), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                torch.position.set(x, 1.5, z);
                scene.add(torch); levelObjects.push(torch);
                const flame = new THREE.PointLight(0xff6600, 0.5, 10);
                flame.position.set(x, 3.5, z);
                scene.add(flame); levelObjects.push(flame);
            }
        }

        function createLibraryLevel() {
            // Biblioth√®que perdue
            const woodMaterial = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
            // √âtag√®res
            for (let row = -3; row <= 3; row++) {
                for (let col = -2; col <= 2; col++) {
                    if (Math.abs(row) > 1 || Math.abs(col) > 1) {
                        const shelf = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 1), woodMaterial);
                        shelf.position.set(col * 12, 2, row * 8);
                        scene.add(shelf); levelObjects.push(shelf);
                        addSolidObject(col * 12, row * 8, 3, 4);
                        // Livres (rectangles color√©s)
                        for (let b = 0; b < 10; b++) {
                            const book = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.5), new THREE.MeshLambertMaterial({ color: seededRandom() * 0xffffff }));
                            book.position.set(col * 12 - 2.5 + b * 0.5, 2 + seededRandom() * 1.5, row * 8);
                            scene.add(book); levelObjects.push(book);
                        }
                    }
                }
            }
            // Table centrale
            const table = new THREE.Mesh(new THREE.BoxGeometry(8, 1, 4), woodMaterial);
            table.position.set(0, 0.5, 0);
            scene.add(table); levelObjects.push(table);
            addSolidObject(0, 0, 4, 1);
        }

        function createThroneLevel() {
            // Salle du tr√¥ne
            const stoneMaterial = new THREE.MeshLambertMaterial({ color: 0x212121 });
            // Tr√¥ne
            const throne = new THREE.Group();
            const seat = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 2), new THREE.MeshLambertMaterial({ color: 0x8b0000 }));
            seat.position.y = 0.5;
            throne.add(seat);
            const back = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.5), new THREE.MeshLambertMaterial({ color: 0x8b0000 }));
            back.position.set(0, 2.5, -0.75);
            throne.add(back);
            throne.position.set(0, 0, -35);
            scene.add(throne); levelObjects.push(throne);
            addSolidObject(0, -35, 1.5, 4);
            // Colonnes
            for (let i = -3; i <= 3; i++) {
                for (let side = -1; side <= 1; side += 2) {
                    const column = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 10), stoneMaterial);
                    column.position.set(side * 15, 5, i * 10);
                    scene.add(column); levelObjects.push(column);
                    addSolidObject(side * 15, i * 10, 1, 10);
                }
            }
            // Tapis rouge
            const carpet = new THREE.Mesh(new THREE.PlaneGeometry(4, 60), new THREE.MeshLambertMaterial({ color: 0x8b0000 }));
            carpet.rotation.x = -Math.PI / 2;
            carpet.position.set(0, 0.01, 0);
            scene.add(carpet); levelObjects.push(carpet);
        }

        // ==========================================
        // === NOUVEAUX NIVEAUX CHAPITRE 4 ===
        // ==========================================

        function createIcyAbyssLevel() {
            // Ab√Æme glacial
            createSnowLevel();
            // Crevasses (lignes sombres)
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const crevasse = new THREE.Mesh(new THREE.BoxGeometry(1, 0.5, 10 + seededRandom() * 10), new THREE.MeshLambertMaterial({ color: 0x1a237e }));
                crevasse.position.set(x, 0.01, z);
                crevasse.rotation.y = seededRandom() * Math.PI;
                scene.add(crevasse); levelObjects.push(crevasse);
            }
            // Pics de glace
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const h = 3 + seededRandom() * 5;
                const spike = new THREE.Mesh(new THREE.ConeGeometry(1, h, 6), new THREE.MeshLambertMaterial({ color: 0xb3e5fc, transparent: true, opacity: 0.8 }));
                spike.position.set(x, h / 2, z);
                scene.add(spike); levelObjects.push(spike);
                addSolidObject(x, z, 1, h);
            }
        }

        function createLavaLandLevel() {
            // Terre de lave
            // Rivi√®res de lave
            for (let i = 0; i < 8; i++) {
                const lava = new THREE.Mesh(new THREE.PlaneGeometry(3, 50), new THREE.MeshBasicMaterial({ color: 0xff4500 }));
                lava.rotation.x = -Math.PI / 2;
                lava.position.set((seededRandom() - 0.5) * 60, 0.02, (seededRandom() - 0.5) * 60);
                lava.rotation.z = seededRandom() * Math.PI;
                scene.add(lava); levelObjects.push(lava);
            }
            // Rochers noirs
            for (let i = 0; i < 25; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 1 + seededRandom() * 2;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
                rock.position.set(x, r * 0.4, z);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(x, z, r, r * 1.4);
            }
            // Fum√©e (sph√®res grises)
            for (let i = 0; i < 10; i++) {
                const smoke = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 8), new THREE.MeshLambertMaterial({ color: 0x424242, transparent: true, opacity: 0.5 }));
                smoke.position.set((seededRandom() - 0.5) * 70, 3 + seededRandom() * 3, (seededRandom() - 0.5) * 70);
                scene.add(smoke); levelObjects.push(smoke);
            }
        }

        function createToxicLevel() {
            // Caverne toxique
            createCaveLevel();
            // Flaques toxiques
            for (let i = 0; i < 12; i++) {
                const puddle = new THREE.Mesh(new THREE.CircleGeometry(2 + seededRandom() * 3, 16), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 }));
                puddle.rotation.x = -Math.PI / 2;
                puddle.position.set((seededRandom() - 0.5) * 70, 0.02, (seededRandom() - 0.5) * 70);
                scene.add(puddle); levelObjects.push(puddle);
            }
            // Bulles (petites sph√®res vertes)
            for (let i = 0; i < 30; i++) {
                const bubble = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0x7fff00 }));
                bubble.position.set((seededRandom() - 0.5) * 70, 0.5 + seededRandom() * 2, (seededRandom() - 0.5) * 70);
                scene.add(bubble); levelObjects.push(bubble);
            }
        }

        function createVoidLevel() {
            // Void cosmique
            // Plateformes flottantes
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const r = 3 + seededRandom() * 4;
                const platform = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 1, 16), new THREE.MeshLambertMaterial({ color: 0x1a1a2e }));
                platform.position.set(x, -0.5 + seededRandom() * 2, z);
                scene.add(platform); levelObjects.push(platform);
                platforms.push({ x, z, radius: r, height: platform.position.y + 0.5 });
            }
            // √âtoiles lointaines
            for (let i = 0; i < 100; i++) {
                const star = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                star.position.set((seededRandom() - 0.5) * 200, 20 + seededRandom() * 30, (seededRandom() - 0.5) * 200);
                scene.add(star); levelObjects.push(star);
            }
            // Cristaux flottants
            for (let i = 0; i < 10; i++) {
                const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(1 + seededRandom()), new THREE.MeshLambertMaterial({ color: 0x9c27b0, emissive: 0x4a148c }));
                crystal.position.set((seededRandom() - 0.5) * 60, 3 + seededRandom() * 5, (seededRandom() - 0.5) * 60);
                scene.add(crystal); levelObjects.push(crystal);
            }
        }

        function createFrozenHellLevel() {
            // Enfer gel√©
            createIcyAbyssLevel();
            // Flammes bleues
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const flame = new THREE.Mesh(new THREE.ConeGeometry(0.5, 2, 8), new THREE.MeshBasicMaterial({ color: 0x00bfff }));
                flame.position.set(x, 1, z);
                scene.add(flame); levelObjects.push(flame);
                const light = new THREE.PointLight(0x00bfff, 0.5, 8);
                light.position.set(x, 2, z);
                scene.add(light); levelObjects.push(light);
            }
        }

        function createPeakLevel() {
            // Pic vertigineux
            // Montagne centrale
            const mountain = new THREE.Mesh(new THREE.ConeGeometry(30, 25, 8), new THREE.MeshLambertMaterial({ color: 0x78909c }));
            mountain.position.set(0, 12.5, 0);
            scene.add(mountain); levelObjects.push(mountain);
            // Neige au sommet
            const snow = new THREE.Mesh(new THREE.ConeGeometry(10, 8, 8), new THREE.MeshLambertMaterial({ color: 0xffffff }));
            snow.position.set(0, 21, 0);
            scene.add(snow); levelObjects.push(snow);
            addSolidObject(0, 0, 30, 25);
            // Rochers autour
            for (let i = 0; i < 20; i++) {
                const angle = seededRandom() * Math.PI * 2;
                const dist = 35 + seededRandom() * 10;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const r = 1 + seededRandom() * 2;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x607d8b }));
                rock.position.set(x, r * 0.4, z);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(x, z, r, r * 1.4);
            }
        }

        function createAbyssLevel() {
            // Gouffre sans fin
            // Bordure du gouffre
            const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x212121 });
            for (let i = 0; i < 36; i++) {
                const angle = (i / 36) * Math.PI * 2;
                const x = Math.cos(angle) * 20;
                const z = Math.sin(angle) * 20;
                const pillar = new THREE.Mesh(new THREE.BoxGeometry(3, 4 + seededRandom() * 3, 3), edgeMaterial);
                pillar.position.set(x, 2, z);
                scene.add(pillar); levelObjects.push(pillar);
                addSolidObject(x, z, 1.5, 6);
            }
            // Passerelles
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const bridge = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 25), edgeMaterial);
                bridge.position.set(Math.cos(angle) * 10, 0.25, Math.sin(angle) * 10);
                bridge.rotation.y = angle;
                scene.add(bridge); levelObjects.push(bridge);
            }
            // Rochers flottants
            for (let i = 0; i < 10; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                if (Math.sqrt(x * x + z * z) > 25) {
                    const r = 2 + seededRandom() * 3;
                    const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), edgeMaterial);
                    rock.position.set(x, r * 0.4, z);
                    scene.add(rock); levelObjects.push(rock);
                    addSolidObject(x, z, r, r * 1.4);
                }
            }
        }

        function createCorruptedLevel() {
            // Terres corrompues
            // Sol corrompu (taches violettes)
            for (let i = 0; i < 30; i++) {
                const stain = new THREE.Mesh(new THREE.CircleGeometry(3 + seededRandom() * 4, 8), new THREE.MeshBasicMaterial({ color: 0x9c27b0, transparent: true, opacity: 0.6 }));
                stain.rotation.x = -Math.PI / 2;
                stain.position.set((seededRandom() - 0.5) * 80, 0.01, (seededRandom() - 0.5) * 80);
                scene.add(stain); levelObjects.push(stain);
            }
            // Arbres corrompus
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 5), new THREE.MeshLambertMaterial({ color: 0x4a148c }));
                trunk.position.y = 2.5;
                tree.add(trunk);
                // Branches tordues
                for (let b = 0; b < 3; b++) {
                    const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 2), new THREE.MeshLambertMaterial({ color: 0x4a148c }));
                    branch.position.set((seededRandom() - 0.5) * 1.5, 4 + b * 0.5, (seededRandom() - 0.5) * 1.5);
                    branch.rotation.z = (seededRandom() - 0.5) * 1;
                    tree.add(branch);
                }
                tree.position.set(x, 0, z);
                scene.add(tree); levelObjects.push(tree);
                addSolidObject(x, z, 0.5, 5);
            }
            // Cristaux corrompus
            for (let i = 0; i < 15; i++) {
                const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(1 + seededRandom()), new THREE.MeshLambertMaterial({ color: 0x7b1fa2, emissive: 0x4a148c }));
                crystal.position.set((seededRandom() - 0.5) * 70, 1 + seededRandom() * 2, (seededRandom() - 0.5) * 70);
                scene.add(crystal); levelObjects.push(crystal);
                addSolidObject(crystal.position.x, crystal.position.z, 1, 2);
            }
        }

        function createGlacierLevel() {
            // Glacier mortel
            createSnowLevel();
            // Murs de glace
            for (let i = 0; i < 10; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const w = 5 + seededRandom() * 5;
                const h = 3 + seededRandom() * 4;
                const iceWall = new THREE.Mesh(new THREE.BoxGeometry(w, h, 1), new THREE.MeshLambertMaterial({ color: 0xb3e5fc, transparent: true, opacity: 0.7 }));
                iceWall.position.set(x, h / 2, z);
                iceWall.rotation.y = seededRandom() * Math.PI;
                scene.add(iceWall); levelObjects.push(iceWall);
                addSolidObject(x, z, w / 2, h);
            }
        }

        function createLunarLevel() {
            // Crat√®re lunaire
            // Sol avec crat√®res
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 3 + seededRandom() * 5;
                const crater = new THREE.Mesh(new THREE.RingGeometry(r * 0.5, r, 16), new THREE.MeshLambertMaterial({ color: 0x616161, side: THREE.DoubleSide }));
                crater.rotation.x = -Math.PI / 2;
                crater.position.set(x, 0.02, z);
                scene.add(crater); levelObjects.push(crater);
            }
            // Rochers lunaires
            for (let i = 0; i < 25; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 0.8 + seededRandom() * 1.5;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x757575 }));
                rock.position.set(x, r * 0.4, z);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(x, z, r, r * 1.4);
            }
            // Drapeau
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4), new THREE.MeshLambertMaterial({ color: 0xc0c0c0 }));
            pole.position.set(0, 2, 0);
            scene.add(pole); levelObjects.push(pole);
            const flag = new THREE.Mesh(new THREE.PlaneGeometry(2, 1.2), new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }));
            flag.position.set(1, 3.5, 0);
            scene.add(flag); levelObjects.push(flag);
        }

        function createFirestormLevel() {
            // Temp√™te de feu
            createLavaLandLevel();
            // Tornades de feu (cylindres orange)
            for (let i = 0; i < 6; i++) {
                const tornado = new THREE.Mesh(new THREE.CylinderGeometry(1, 3, 10, 8, 1, true), new THREE.MeshBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.6, side: THREE.DoubleSide }));
                tornado.position.set((seededRandom() - 0.5) * 70, 5, (seededRandom() - 0.5) * 70);
                scene.add(tornado); levelObjects.push(tornado);
            }
        }

        function createOceanAbyssLevel() {
            // Abysse oc√©anique
            // Coraux
            const coralColors = [0xff6b6b, 0xfeca57, 0xff9ff3, 0x00d2d3];
            for (let i = 0; i < 30; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const color = coralColors[Math.floor(seededRandom() * coralColors.length)];
                const coral = new THREE.Mesh(new THREE.ConeGeometry(0.5 + seededRandom() * 0.5, 2 + seededRandom() * 2, 5), new THREE.MeshLambertMaterial({ color }));
                coral.position.set(x, 1, z);
                scene.add(coral); levelObjects.push(coral);
                addSolidObject(x, z, 0.5, 3);
            }
            // Algues g√©antes
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                for (let a = 0; a < 5; a++) {
                    const h = 3 + seededRandom() * 4;
                    const algae = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, h), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
                    algae.position.set(x + (seededRandom() - 0.5), h / 2, z + (seededRandom() - 0.5));
                    algae.rotation.x = (seededRandom() - 0.5) * 0.3;
                    scene.add(algae); levelObjects.push(algae);
                }
            }
            // Rochers sous-marins
            for (let i = 0; i < 15; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const r = 1 + seededRandom() * 2;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(r), new THREE.MeshLambertMaterial({ color: 0x37474f }));
                rock.position.set(x, r * 0.4, z);
                scene.add(rock); levelObjects.push(rock);
                addSolidObject(x, z, r, r * 1.4);
            }
            // Bulles
            for (let i = 0; i < 50; i++) {
                const bubble = new THREE.Mesh(new THREE.SphereGeometry(0.2 + seededRandom() * 0.3), new THREE.MeshLambertMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.5 }));
                bubble.position.set((seededRandom() - 0.5) * 80, seededRandom() * 10, (seededRandom() - 0.5) * 80);
                scene.add(bubble); levelObjects.push(bubble);
            }
        }

        function createNothingnessLevel() {
            // N√©ant √©ternel - presque rien
            // Quelques plateformes flottantes
            for (let i = 0; i < 8; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const r = 2 + seededRandom() * 3;
                const platform = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 0.5, 8), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
                platform.position.set(x, seededRandom() * 2, z);
                scene.add(platform); levelObjects.push(platform);
                platforms.push({ x, z, radius: r, height: platform.position.y + 0.25 });
            }
            // Lumi√®res √©parses
            for (let i = 0; i < 5; i++) {
                const light = new THREE.PointLight(0xffffff, 0.3, 20);
                light.position.set((seededRandom() - 0.5) * 80, 5, (seededRandom() - 0.5) * 80);
                scene.add(light); levelObjects.push(light);
            }
        }

        function createInvertedLevel() {
            // Monde invers√©
            // Arbres √† l'envers (racines en haut)
            for (let i = 0; i < 20; i++) {
                const x = (seededRandom() - 0.5) * 70;
                const z = (seededRandom() - 0.5) * 70;
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 5), new THREE.MeshLambertMaterial({ color: 0x8d6e63 }));
                trunk.position.y = 2.5;
                tree.add(trunk);
                const leaves = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), new THREE.MeshLambertMaterial({ color: 0x7b1fa2 }));
                leaves.position.y = 0;
                tree.add(leaves);
                // Racines en haut
                for (let r = 0; r < 3; r++) {
                    const root = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.05, 1.5), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                    root.position.set((seededRandom() - 0.5) * 0.8, 5.5, (seededRandom() - 0.5) * 0.8);
                    root.rotation.z = (seededRandom() - 0.5) * 0.5;
                    tree.add(root);
                }
                tree.position.set(x, 0, z);
                scene.add(tree); levelObjects.push(tree);
                addSolidObject(x, z, 0.4, 6);
            }
            // Cristaux invers√©s
            for (let i = 0; i < 15; i++) {
                const crystal = new THREE.Mesh(new THREE.ConeGeometry(1, 3, 6), new THREE.MeshLambertMaterial({ color: 0xad1457 }));
                crystal.position.set((seededRandom() - 0.5) * 70, 1.5, (seededRandom() - 0.5) * 70);
                crystal.rotation.x = Math.PI; // Invers√©
                scene.add(crystal); levelObjects.push(crystal);
                addSolidObject(crystal.position.x, crystal.position.z, 1, 3);
            }
        }

        function createFractureLevel() {
            // Fracture dimensionnelle
            // Portails (torus)
            const portalColors = [0x9c27b0, 0x00bcd4, 0xff5722, 0x4caf50];
            for (let i = 0; i < 6; i++) {
                const x = (seededRandom() - 0.5) * 60;
                const z = (seededRandom() - 0.5) * 60;
                const color = portalColors[i % portalColors.length];
                const portal = new THREE.Mesh(new THREE.TorusGeometry(2, 0.3, 8, 16), new THREE.MeshBasicMaterial({ color }));
                portal.position.set(x, 3, z);
                portal.rotation.y = seededRandom() * Math.PI;
                scene.add(portal); levelObjects.push(portal);
                const light = new THREE.PointLight(color, 0.5, 10);
                light.position.set(x, 3, z);
                scene.add(light); levelObjects.push(light);
            }
            // Fragments de r√©alit√©
            for (let i = 0; i < 30; i++) {
                const fragment = new THREE.Mesh(new THREE.TetrahedronGeometry(1 + seededRandom()), new THREE.MeshLambertMaterial({ color: 0x311b92 }));
                fragment.position.set((seededRandom() - 0.5) * 80, seededRandom() * 5, (seededRandom() - 0.5) * 80);
                fragment.rotation.set(seededRandom(), seededRandom(), seededRandom());
                scene.add(fragment); levelObjects.push(fragment);
                addSolidObject(fragment.position.x, fragment.position.z, 1, 2);
            }
        }

        function createChaosLevel() {
            // Chaos primordial
            // Tout m√©lang√©
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0xff0000 }),
                new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
                new THREE.MeshLambertMaterial({ color: 0x0000ff }),
                new THREE.MeshLambertMaterial({ color: 0xffff00 }),
                new THREE.MeshLambertMaterial({ color: 0xff00ff })
            ];
            // Formes al√©atoires
            for (let i = 0; i < 40; i++) {
                const x = (seededRandom() - 0.5) * 80;
                const z = (seededRandom() - 0.5) * 80;
                const mat = materials[Math.floor(seededRandom() * materials.length)];
                let shape;
                const type = Math.floor(seededRandom() * 5);
                const r = 1 + seededRandom() * 2;
                switch (type) {
                    case 0: shape = new THREE.Mesh(new THREE.BoxGeometry(r, r, r), mat); break;
                    case 1: shape = new THREE.Mesh(new THREE.SphereGeometry(r), mat); break;
                    case 2: shape = new THREE.Mesh(new THREE.ConeGeometry(r, r * 2), mat); break;
                    case 3: shape = new THREE.Mesh(new THREE.OctahedronGeometry(r), mat); break;
                    case 4: shape = new THREE.Mesh(new THREE.DodecahedronGeometry(r), mat); break;
                }
                shape.position.set(x, r, z);
                shape.rotation.set(seededRandom() * Math.PI, seededRandom() * Math.PI, seededRandom() * Math.PI);
                scene.add(shape); levelObjects.push(shape);
                addSolidObject(x, z, r, r * 2);
            }
            // Lumi√®res chaotiques
            for (let i = 0; i < 10; i++) {
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
                const light = new THREE.PointLight(colors[i % 5], 0.5, 15);
                light.position.set((seededRandom() - 0.5) * 70, 5, (seededRandom() - 0.5) * 70);
                scene.add(light); levelObjects.push(light);
            }
        }

        // ==========================================
        // === PUZZLES CHAPITRE 5 ===
        // ==========================================

        function createKeyDoorPuzzle() {
            // R√©utiliser createFinalLevel pour le puzzle cl√©/porte
            createFinalLevel();
        }

        function createSwitchesPuzzle() {
            // 3 interrupteurs √† activer dans l'ordre
            createRuinsLevel();
            // Interrupteurs
            const switchPositions = [
                { x: -20, z: -20, order: 1 },
                { x: 25, z: 0, order: 2 },
                { x: -10, z: 30, order: 3 }
            ];
            puzzleObjects.switches = [];
            switchPositions.forEach((pos, i) => {
                const switchGroup = new THREE.Group();
                const base = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.3, 1.5), new THREE.MeshLambertMaterial({ color: 0x424242 }));
                base.position.y = 0.15;
                switchGroup.add(base);
                const lever = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.5, 0.3), new THREE.MeshLambertMaterial({ color: 0x8b0000 }));
                lever.position.y = 0.9;
                switchGroup.add(lever);
                const label = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                label.position.set(0, 2, 0);
                label.rotation.y = Math.PI / 4;
                switchGroup.add(label);
                switchGroup.position.set(pos.x, 0, pos.z);
                switchGroup.userData = { type: 'switch', index: i, order: pos.order, activated: false };
                scene.add(switchGroup);
                levelObjects.push(switchGroup);
                puzzleObjects.switches.push(switchGroup);
            });
        }

        function createLeverPuzzle() {
            // Levier cach√©
            createCanyonLevel();
            // Levier derri√®re des rochers
            const lever = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.3), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
            base.position.y = 0.15;
            lever.add(base);
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2, 0.2), new THREE.MeshLambertMaterial({ color: 0x424242 }));
            handle.position.y = 1.15;
            handle.rotation.z = 0.5; // Levier non tir√©
            lever.add(handle);
            lever.position.set(35, 0, 35);
            lever.userData = { type: 'lever', pulled: false };
            scene.add(lever);
            levelObjects.push(lever);
            puzzleObjects.lever = lever;
            // Rochers qui cachent
            for (let i = 0; i < 5; i++) {
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(2 + seededRandom()), new THREE.MeshLambertMaterial({ color: 0xcd853f }));
                rock.position.set(33 + seededRandom() * 4, 1, 33 + seededRandom() * 4);
                scene.add(rock); levelObjects.push(rock);
            }
        }

        function createGemsPuzzle() {
            // Collecter 3 gemmes
            createCrystalLevel();
            puzzleObjects.gems = [];
            const gemPositions = [
                { x: -30, z: -25 },
                { x: 35, z: 10 },
                { x: -5, z: 40 }
            ];
            const gemColors = [0xff0000, 0x00ff00, 0x0000ff];
            gemPositions.forEach((pos, i) => {
                const gem = new THREE.Mesh(new THREE.OctahedronGeometry(1), new THREE.MeshLambertMaterial({ color: gemColors[i], emissive: gemColors[i], emissiveIntensity: 0.3 }));
                gem.position.set(pos.x, 1.5, pos.z);
                gem.userData = { type: 'gem', index: i, collected: false };
                scene.add(gem);
                levelObjects.push(gem);
                puzzleObjects.gems.push(gem);
                // Lumi√®re
                const light = new THREE.PointLight(gemColors[i], 0.5, 8);
                light.position.set(pos.x, 2, pos.z);
                scene.add(light); levelObjects.push(light);
            });
        }

        function createPushRockPuzzle() {
            // Rocher √† pousser
            createCaveLevel();
            // Rocher poussable
            const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(2.5), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
            rock.position.set(-20, 1.5, 0);
            rock.userData = { type: 'pushable', pushed: false };
            scene.add(rock);
            levelObjects.push(rock);
            puzzleObjects.pushableRock = rock;
            // Marqueur o√π pousser
            const target = new THREE.Mesh(new THREE.CircleGeometry(3, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.5 }));
            target.rotation.x = -Math.PI / 2;
            target.position.set(-20, 0.01, -20);
            scene.add(target); levelObjects.push(target);
        }

        function createTorchesPuzzle() {
            // 3 torches √† allumer
            createTempleLevel();
            puzzleObjects.torches = [];
            const torchPositions = [
                { x: -25, z: -25 },
                { x: 25, z: -25 },
                { x: 0, z: 30 }
            ];
            torchPositions.forEach((pos, i) => {
                const torch = new THREE.Group();
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 3), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
                pole.position.y = 1.5;
                torch.add(pole);
                const bowl = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.3, 0.4), new THREE.MeshLambertMaterial({ color: 0x424242 }));
                bowl.position.y = 3.2;
                torch.add(bowl);
                torch.position.set(pos.x, 0, pos.z);
                torch.userData = { type: 'torch', index: i, lit: false, flame: null, light: null };
                scene.add(torch);
                levelObjects.push(torch);
                puzzleObjects.torches.push(torch);
            });
        }

        function createPlatesPuzzle() {
            // Plaques de pression en s√©quence
            createGhostTownLevel();
            puzzleObjects.plates = [];
            const platePositions = [
                { x: -15, z: -15, order: 1 },
                { x: 15, z: -15, order: 3 },
                { x: -15, z: 15, order: 2 },
                { x: 15, z: 15, order: 4 }
            ];
            platePositions.forEach((pos, i) => {
                const plate = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 3), new THREE.MeshLambertMaterial({ color: 0x607d8b }));
                plate.position.set(pos.x, 0.1, pos.z);
                plate.userData = { type: 'plate', index: i, order: pos.order, pressed: false };
                scene.add(plate);
                levelObjects.push(plate);
                puzzleObjects.plates.push(plate);
                // Num√©ro sur la plaque
                const label = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 }));
                label.rotation.x = -Math.PI / 2;
                label.position.set(pos.x, 0.21, pos.z);
                scene.add(label); levelObjects.push(label);
            });
        }

        function createCodePuzzle() {
            // Code secret √† trouver
            createLibraryLevel();
            // Panneau de code
            const panel = new THREE.Group();
            const back = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 0.3), new THREE.MeshLambertMaterial({ color: 0x424242 }));
            panel.add(back);
            // √âcran
            const screen = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 1), new THREE.MeshBasicMaterial({ color: 0x1b5e20 }));
            screen.position.z = 0.16;
            panel.add(screen);
            panel.position.set(0, 1.5, -10);
            panel.userData = { type: 'codePanel' };
            scene.add(panel);
            levelObjects.push(panel);
            puzzleObjects.codePanel = panel;
            // Indices sur les murs (texte repr√©sent√© par des carr√©s)
            const hints = [
                { x: -30, z: 0, digit: 1 },
                { x: 30, z: 0, digit: 2 },
                { x: 0, z: -30, digit: 3 },
                { x: 0, z: 30, digit: 4 }
            ];
            hints.forEach(h => {
                const hint = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ color: 0xffd700 }));
                hint.position.set(h.x, 2, h.z);
                hint.lookAt(0, 2, 0);
                scene.add(hint); levelObjects.push(hint);
            });
        }

        function createDoubleKeyPuzzle() {
            // 2 cl√©s et 2 portes
            createCastleRuinsLevel();
            puzzleObjects.keys = [];
            puzzleObjects.doors = [];
            // Cl√© 1
            const key1 = createPuzzleKey(0xffd700);
            key1.position.set(-35, 1.5, 20);
            key1.userData = { type: 'key', index: 0, collected: false };
            scene.add(key1);
            levelObjects.push(key1);
            puzzleObjects.keys.push(key1);
            // Cl√© 2
            const key2 = createPuzzleKey(0xc0c0c0);
            key2.position.set(35, 1.5, -20);
            key2.userData = { type: 'key', index: 1, collected: false };
            scene.add(key2);
            levelObjects.push(key2);
            puzzleObjects.keys.push(key2);
            // Porte 1 (or)
            const door1 = createPuzzleDoor(0xffd700);
            door1.position.set(-20, 2, -35);
            door1.userData = { type: 'door', index: 0, keyIndex: 0, opened: false };
            scene.add(door1);
            levelObjects.push(door1);
            addSolidObject(-20, -35, 2, 4);
            puzzleObjects.doors.push(door1);
            // Porte 2 (argent)
            const door2 = createPuzzleDoor(0xc0c0c0);
            door2.position.set(20, 2, -35);
            door2.userData = { type: 'door', index: 1, keyIndex: 1, opened: false };
            scene.add(door2);
            levelObjects.push(door2);
            addSolidObject(20, -35, 2, 4);
            puzzleObjects.doors.push(door2);
        }

        function createPuzzleKey(color) {
            const key = new THREE.Group();
            const handle = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.1, 8, 16), new THREE.MeshLambertMaterial({ color }));
            handle.rotation.x = Math.PI / 2;
            key.add(handle);
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1), new THREE.MeshLambertMaterial({ color }));
            shaft.position.y = -0.5;
            key.add(shaft);
            const teeth = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.2, 0.08), new THREE.MeshLambertMaterial({ color }));
            teeth.position.y = -0.9;
            key.add(teeth);
            return key;
        }

        function createPuzzleDoor(color) {
            const door = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.3), new THREE.MeshLambertMaterial({ color }));
            return door;
        }

        function createColorCrystalsPuzzle() {
            // Cristaux √† activer dans l'ordre des couleurs
            createDarkDimensionLevel();
            puzzleObjects.crystals = [];
            const crystalData = [
                { x: -20, z: -20, color: 0xff0000, name: 'red', order: 1 },
                { x: 20, z: -20, color: 0x0000ff, name: 'blue', order: 2 },
                { x: -20, z: 20, color: 0x00ff00, name: 'green', order: 3 },
                { x: 20, z: 20, color: 0xffff00, name: 'yellow', order: 4 }
            ];
            crystalData.forEach((data, i) => {
                const crystal = new THREE.Mesh(new THREE.OctahedronGeometry(1.5), new THREE.MeshLambertMaterial({ color: data.color, emissive: 0x000000 }));
                crystal.position.set(data.x, 2, data.z);
                crystal.userData = { type: 'colorCrystal', index: i, colorName: data.name, order: data.order, activated: false };
                scene.add(crystal);
                levelObjects.push(crystal);
                puzzleObjects.crystals.push(crystal);
            });
            // Indice au centre
            const hint = new THREE.Mesh(new THREE.PlaneGeometry(3, 1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            hint.rotation.x = -Math.PI / 2;
            hint.position.set(0, 0.01, 0);
            scene.add(hint); levelObjects.push(hint);
        }

        function createTreasureMapPuzzle() {
            // Trouver le fragment de carte
            createBeachLevel();
            // Carte cach√©e
            const map = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1), new THREE.MeshBasicMaterial({ color: 0xdeb887, side: THREE.DoubleSide }));
            map.position.set(40, 0.5, -30);
            map.rotation.x = -Math.PI / 4;
            map.userData = { type: 'treasureMap', found: false };
            scene.add(map);
            levelObjects.push(map);
            puzzleObjects.map = map;
            // X qui marque l'emplacement
            const X = new THREE.Group();
            const line1 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 0.3), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            line1.rotation.y = Math.PI / 4;
            X.add(line1);
            const line2 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 0.3), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            line2.rotation.y = -Math.PI / 4;
            X.add(line2);
            X.position.set(-30, 0.06, 25);
            X.visible = false; // Visible apr√®s avoir trouv√© la carte
            scene.add(X);
            levelObjects.push(X);
        }

        function createWaterPuzzle() {
            // Ouvrir la vanne pour r√©v√©ler
            createSwampLevel();
            // Vanne
            const valve = new THREE.Group();
            const pipe = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 2), new THREE.MeshLambertMaterial({ color: 0x424242 }));
            pipe.position.y = 1;
            valve.add(pipe);
            const wheel = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.1, 8, 16), new THREE.MeshLambertMaterial({ color: 0xff0000 }));
            wheel.position.set(0, 2.2, 0);
            wheel.rotation.x = Math.PI / 2;
            valve.add(wheel);
            valve.position.set(30, 0, 30);
            valve.userData = { type: 'valve', opened: false };
            scene.add(valve);
            levelObjects.push(valve);
            puzzleObjects.waterSource = valve;
            // Zone √† inonder
            const pool = new THREE.Mesh(new THREE.CircleGeometry(8, 16), new THREE.MeshLambertMaterial({ color: 0x4a5d23, transparent: true, opacity: 0.8 }));
            pool.rotation.x = -Math.PI / 2;
            pool.position.set(-25, 0.01, -25);
            scene.add(pool); levelObjects.push(pool);
        }

        function createBreakWallPuzzle() {
            // Mur fragile √† briser
            createFortressLevel();
            // Mur fragile (diff√©rent des autres)
            const wall = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 0.5), new THREE.MeshLambertMaterial({ color: 0x8d6e63 }));
            wall.position.set(0, 2, -20);
            wall.userData = { type: 'breakableWall', broken: false };
            scene.add(wall);
            levelObjects.push(wall);
            addSolidObject(0, -20, 3, 4);
            puzzleObjects.breakableWall = wall;
            // Indice de fragilit√© (fissures)
            for (let i = 0; i < 3; i++) {
                const crack = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2 + seededRandom() * 2, 0.01), new THREE.MeshBasicMaterial({ color: 0x1a1a1a }));
                crack.position.set((seededRandom() - 0.5) * 4, 2, -19.7);
                crack.rotation.z = (seededRandom() - 0.5) * 0.5;
                scene.add(crack); levelObjects.push(crack);
            }
        }

        function createRunesPuzzle() {
            // 4 runes √† collecter
            createAztecLevel();
            puzzleObjects.runes = [];
            const runePositions = [
                { x: -35, z: -35 },
                { x: 35, z: -35 },
                { x: -35, z: 35 },
                { x: 35, z: 35 }
            ];
            const runeColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            runePositions.forEach((pos, i) => {
                const rune = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshBasicMaterial({ color: runeColors[i], side: THREE.DoubleSide }));
                rune.position.set(pos.x, 1, pos.z);
                rune.userData = { type: 'rune', index: i, collected: false };
                scene.add(rune);
                levelObjects.push(rune);
                puzzleObjects.runes.push(rune);
            });
        }

        function createPillarsPuzzle() {
            // Piliers rotatifs
            createColiseumLevel();
            puzzleObjects.pillars = [];
            const pillarPositions = [
                { x: -15, z: 0 },
                { x: 0, z: 0 },
                { x: 15, z: 0 }
            ];
            pillarPositions.forEach((pos, i) => {
                const pillar = new THREE.Group();
                const base = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.5), new THREE.MeshLambertMaterial({ color: 0xd4b896 }));
                base.position.y = 0.25;
                pillar.add(base);
                const column = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 4), new THREE.MeshLambertMaterial({ color: 0xd4b896 }));
                column.position.y = 2.5;
                pillar.add(column);
                // Symbole sur le pilier
                const symbol = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial({ color: 0x1a1a1a }));
                symbol.position.set(0, 2.5, 1.01);
                pillar.add(symbol);
                pillar.position.set(pos.x, 0, pos.z);
                pillar.userData = { type: 'pillar', index: i, rotation: 0, aligned: false };
                scene.add(pillar);
                levelObjects.push(pillar);
                addSolidObject(pos.x, pos.z, 1.5, 4.5);
                puzzleObjects.pillars.push(pillar);
            });
        }

        function createGhostPuzzle() {
            // Suivre le fant√¥me
            createGhostTownLevel();
            // Fant√¥me guide
            const ghost = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, emissive: 0xaaaaff }));
            ghost.position.set(0, 2, 0);
            ghost.userData = {
                type: 'ghost', waypoint: 0, waypoints: [
                    { x: 0, z: 0 },
                    { x: -20, z: -10 },
                    { x: -30, z: 20 },
                    { x: 10, z: 35 },
                    { x: 40, z: 20 } // Destination finale
                ]
            };
            scene.add(ghost);
            levelObjects.push(ghost);
            puzzleObjects.ghost = ghost;
        }

        function createSeedPuzzle() {
            // Planter et arroser une graine
            createGardenLevel();
            // Graine
            const seed = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
            seed.position.set(20, 0.3, 20);
            seed.userData = { type: 'seed', planted: false };
            scene.add(seed);
            levelObjects.push(seed);
            puzzleObjects.seed = seed;
            // Pot de fleur (o√π planter)
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(1, 0.8, 1.5), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
            pot.position.set(-20, 0.75, -20);
            scene.add(pot); levelObjects.push(pot);
            // Source d'eau
            const water = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 0.3, 16), new THREE.MeshLambertMaterial({ color: 0x4169e1, transparent: true, opacity: 0.7 }));
            water.position.set(0, 0.15, 30);
            water.userData = { type: 'waterSource' };
            scene.add(water);
            levelObjects.push(water);
        }

        function createMazePuzzle() {
            // Labyrinthe
            // Sol
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x424242 });
            // Murs du labyrinthe
            const mazeWalls = [
                { x: 0, z: -20, w: 40, h: 3 },
                { x: -20, z: 0, w: 3, h: 40, roty: Math.PI / 2 },
                { x: 20, z: 0, w: 3, h: 40, roty: Math.PI / 2 },
                { x: 0, z: 20, w: 40, h: 3 },
                // Int√©rieur
                { x: -10, z: -10, w: 15, h: 3 },
                { x: 10, z: 5, w: 15, h: 3 },
                { x: -5, z: 10, w: 20, h: 3, roty: Math.PI / 2 }
            ];
            mazeWalls.forEach(w => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w.w, w.h, 1), wallMaterial);
                wall.position.set(w.x, w.h / 2, w.z);
                if (w.roty) wall.rotation.y = w.roty;
                scene.add(wall); levelObjects.push(wall);
                addSolidObject(w.x, w.z, w.w / 2, w.h);
            });
            // Sortie marqu√©e
            const exit = new THREE.Mesh(new THREE.PlaneGeometry(3, 3), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));
            exit.rotation.x = -Math.PI / 2;
            exit.position.set(15, 0.01, 15);
            exit.userData = { type: 'mazeExit' };
            scene.add(exit);
            levelObjects.push(exit);
        }

        function createStarsPuzzle() {
            // Aligner les constellations
            createVoidLevel();
            puzzleObjects.stars = [];
            // Constellations √† aligner
            const starPositions = [
                { x: -20, z: -20 },
                { x: 0, z: -25 },
                { x: 20, z: -20 },
                { x: -15, z: 0 },
                { x: 15, z: 0 }
            ];
            starPositions.forEach((pos, i) => {
                const star = new THREE.Mesh(new THREE.OctahedronGeometry(1), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                star.position.set(pos.x, 5, pos.z);
                star.userData = { type: 'star', index: i, aligned: false };
                scene.add(star);
                levelObjects.push(star);
                puzzleObjects.stars.push(star);
                // Lumi√®re
                const light = new THREE.PointLight(0xffff00, 0.3, 10);
                light.position.set(pos.x, 5, pos.z);
                scene.add(light); levelObjects.push(light);
            });
            // Socle central pour aligner
            const pedestal = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.5, 1), new THREE.MeshLambertMaterial({ color: 0x1a1a2e }));
            pedestal.position.set(0, 0.5, 10);
            pedestal.userData = { type: 'starPedestal' };
            scene.add(pedestal);
            levelObjects.push(pedestal);
        }

        function createUltimatePuzzle() {
            // √âpreuve ultime - combinaison de m√©caniques
            createChaosLevel();
            // Cl√©
            const key = createPuzzleKey(0xffd700);
            key.position.set(-40, 1.5, -40);
            key.userData = { type: 'key', index: 0, collected: false };
            scene.add(key);
            levelObjects.push(key);
            puzzleObjects.keys = [key];
            // Porte
            const door = createPuzzleDoor(0xffd700);
            door.position.set(0, 2, -40);
            door.userData = { type: 'door', index: 0, keyIndex: 0, opened: false };
            scene.add(door);
            levelObjects.push(door);
            addSolidObject(0, -40, 2, 4);
            puzzleObjects.doors = [door];
            // Levier derri√®re la porte
            const lever = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.3), new THREE.MeshLambertMaterial({ color: 0x5d4037 }));
            base.position.y = 0.15;
            lever.add(base);
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2, 0.2), new THREE.MeshLambertMaterial({ color: 0x424242 }));
            handle.position.y = 1.15;
            handle.rotation.z = 0.5;
            lever.add(handle);
            lever.position.set(0, 0, -45);
            lever.userData = { type: 'lever', pulled: false };
            scene.add(lever);
            levelObjects.push(lever);
            puzzleObjects.lever = lever;
            // 2 gemmes √† collecter apr√®s le levier
            puzzleObjects.gems = [];
            const gemPositions = [{ x: 40, z: 40 }, { x: -40, z: 40 }];
            const gemColors = [0xff0000, 0x00ff00];
            gemPositions.forEach((pos, i) => {
                const gem = new THREE.Mesh(new THREE.OctahedronGeometry(1), new THREE.MeshLambertMaterial({ color: gemColors[i], emissive: gemColors[i], emissiveIntensity: 0.3 }));
                gem.position.set(pos.x, 1.5, pos.z);
                gem.userData = { type: 'gem', index: i, collected: false };
                gem.visible = false; // Appara√Æt apr√®s le levier
                scene.add(gem);
                levelObjects.push(gem);
                puzzleObjects.gems.push(gem);
            });
        }

        // Fonction pour interagir avec les puzzles du chapitre 5
        function interactPuzzle() {
            if (!isPlaying || currentChapter !== 5) return;

            const levelKey = getLevelKey(currentChapter, currentLevel);
            const config = levelConfigs[levelKey];
            if (!config || !config.puzzleType) return;

            const playerPos = player.position;

            switch (config.puzzleType) {
                case 'keyDoor':
                    interactKeyDoor();
                    break;
                case 'switches':
                    interactSwitches();
                    break;
                case 'lever':
                    interactLever();
                    break;
                case 'gems':
                    interactGems();
                    break;
                case 'torches':
                    interactTorches();
                    break;
                case 'doubleKey':
                    interactDoubleKey();
                    break;
                case 'colorCrystals':
                    interactColorCrystals();
                    break;
                case 'runes':
                    interactRunes();
                    break;
                case 'pillars':
                    interactPillars();
                    break;
                case 'ghost':
                    // Ghost puzzle is automatic
                    break;
                case 'seed':
                    interactSeed();
                    break;
                case 'ultimate':
                    interactUltimate();
                    break;
                default:
                    // Simple interaction puzzles
                    break;
            }
        }

        function interactKeyDoor() {
            // Key/Door puzzle (like original level 20)
            if (level20Key && level20Key.visible && !hasKey) {
                const dx = player.position.x - level20Key.position.x;
                const dz = player.position.z - level20Key.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    hasKey = true;
                    level20Key.visible = false;
                    document.getElementById('hintText').textContent = "üîë Cl√© r√©cup√©r√©e ! Cherche la porte cach√©e...";
                    if (level20Door) level20Door.visible = true;
                    return;
                }
            }

            if (level20Door && level20Door.visible && hasKey && !doorOpened) {
                const dx = player.position.x - level20Door.position.x;
                const dz = player.position.z - level20Door.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 4) {
                    doorOpened = true;
                    level20Door.rotation.y = -Math.PI / 2;
                    level20Door.position.x += 1.5;
                    if (level20Rock) level20Rock.visible = false;
                    if (level20RockCollision) {
                        const idx = solidObjects.indexOf(level20RockCollision);
                        if (idx > -1) solidObjects.splice(idx, 1);
                    }
                    level20ButtonHidden = false;
                    redButton.visible = true;
                    document.getElementById('hintText').textContent = "üö™ Porte ouverte ! Le bouton est r√©v√©l√© ! üî¥";
                }
            }
        }

        function interactSwitches() {
            puzzleObjects.switches.forEach((sw, i) => {
                if (sw.userData.activated) return;
                const dx = player.position.x - sw.position.x;
                const dz = player.position.z - sw.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    const expectedOrder = puzzleState.switchOrder.length + 1;
                    if (sw.userData.order === expectedOrder) {
                        sw.userData.activated = true;
                        sw.children[1].rotation.z = 0.8; // Pull lever
                        puzzleState.switchOrder.push(i);
                        document.getElementById('hintText').textContent = `Interrupteur ${expectedOrder}/3 activ√© ! ‚úì`;

                        if (puzzleState.switchOrder.length === 3) {
                            level20ButtonHidden = false;
                            redButton.visible = true;
                            document.getElementById('hintText').textContent = "Tous les interrupteurs activ√©s ! Le bouton appara√Æt ! üî¥";
                        }
                    } else {
                        // Wrong order - reset
                        puzzleState.switchOrder = [];
                        puzzleObjects.switches.forEach(s => {
                            s.userData.activated = false;
                            s.children[1].rotation.z = 0;
                        });
                        document.getElementById('hintText').textContent = "Mauvais ordre ! Recommence...";
                    }
                }
            });
        }

        function interactLever() {
            if (!puzzleObjects.lever || puzzleState.leverPulled) return;
            const dx = player.position.x - puzzleObjects.lever.position.x;
            const dz = player.position.z - puzzleObjects.lever.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            if (distance < 3) {
                puzzleState.leverPulled = true;
                puzzleObjects.lever.children[1].rotation.z = -0.5;
                level20ButtonHidden = false;
                redButton.visible = true;
                document.getElementById('hintText').textContent = "Levier actionn√© ! Le bouton appara√Æt ! üî¥";
            }
        }

        function interactGems() {
            puzzleObjects.gems.forEach((gem, i) => {
                if (gem.userData.collected) return;
                const dx = player.position.x - gem.position.x;
                const dz = player.position.z - gem.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    gem.userData.collected = true;
                    gem.visible = false;
                    puzzleState.gemsCollected++;
                    document.getElementById('hintText').textContent = `üíé Gemme ${puzzleState.gemsCollected}/3 collect√©e !`;

                    if (puzzleState.gemsCollected === 3) {
                        level20ButtonHidden = false;
                        redButton.visible = true;
                        document.getElementById('hintText').textContent = "Toutes les gemmes collect√©es ! Le bouton appara√Æt ! üî¥";
                    }
                }
            });
        }

        function interactTorches() {
            puzzleObjects.torches.forEach((torch, i) => {
                if (torch.userData.lit) return;
                const dx = player.position.x - torch.position.x;
                const dz = player.position.z - torch.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    torch.userData.lit = true;
                    puzzleState.torchesLit++;
                    // Add flame
                    const flame = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.8, 8), new THREE.MeshBasicMaterial({ color: 0xff4500 }));
                    flame.position.set(0, 3.6, 0);
                    torch.add(flame);
                    // Add light
                    const light = new THREE.PointLight(0xff6600, 0.5, 10);
                    light.position.set(0, 4, 0);
                    torch.add(light);

                    document.getElementById('hintText').textContent = `üî• Torche ${puzzleState.torchesLit}/3 allum√©e !`;

                    if (puzzleState.torchesLit === 3) {
                        level20ButtonHidden = false;
                        redButton.visible = true;
                        document.getElementById('hintText').textContent = "Toutes les torches allum√©es ! Le bouton appara√Æt ! üî¥";
                    }
                }
            });
        }

        function interactDoubleKey() {
            // Check keys
            puzzleObjects.keys.forEach((key, i) => {
                if (key.userData.collected) return;
                const dx = player.position.x - key.position.x;
                const dz = player.position.z - key.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    key.userData.collected = true;
                    key.visible = false;
                    puzzleState.keysCollected++;
                    document.getElementById('hintText').textContent = `üîë Cl√© ${puzzleState.keysCollected}/2 collect√©e !`;
                }
            });

            // Check doors
            puzzleObjects.doors.forEach((door, i) => {
                if (door.userData.opened) return;
                const dx = player.position.x - door.position.x;
                const dz = player.position.z - door.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 4) {
                    const requiredKey = puzzleObjects.keys[door.userData.keyIndex];
                    if (requiredKey && requiredKey.userData.collected) {
                        door.userData.opened = true;
                        door.rotation.y = -Math.PI / 2;
                        door.position.x += 1.5;
                        puzzleState.doorsOpened++;
                        document.getElementById('hintText').textContent = `üö™ Porte ${puzzleState.doorsOpened}/2 ouverte !`;

                        if (puzzleState.doorsOpened === 2) {
                            level20ButtonHidden = false;
                            redButton.visible = true;
                            document.getElementById('hintText').textContent = "Toutes les portes ouvertes ! Le bouton appara√Æt ! üî¥";
                        }
                    } else {
                        document.getElementById('hintText').textContent = "Il te faut la bonne cl√© pour cette porte...";
                    }
                }
            });
        }

        function interactColorCrystals() {
            puzzleObjects.crystals.forEach((crystal, i) => {
                if (crystal.userData.activated) return;
                const dx = player.position.x - crystal.position.x;
                const dz = player.position.z - crystal.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 4) {
                    const expectedIndex = puzzleState.crystalOrder.length;
                    const expectedColor = puzzleState.correctCrystalOrder[expectedIndex];

                    if (crystal.userData.colorName === expectedColor) {
                        crystal.userData.activated = true;
                        crystal.material.emissive.setHex(crystal.material.color.getHex());
                        crystal.material.emissiveIntensity = 0.5;
                        puzzleState.crystalOrder.push(crystal.userData.colorName);
                        document.getElementById('hintText').textContent = `‚úì Cristal ${expectedColor} activ√© ! (${puzzleState.crystalOrder.length}/4)`;

                        if (puzzleState.crystalOrder.length === 4) {
                            level20ButtonHidden = false;
                            redButton.visible = true;
                            document.getElementById('hintText').textContent = "Tous les cristaux activ√©s dans l'ordre ! Le bouton appara√Æt ! üî¥";
                        }
                    } else {
                        // Wrong order
                        puzzleState.crystalOrder = [];
                        puzzleObjects.crystals.forEach(c => {
                            c.userData.activated = false;
                            c.material.emissive.setHex(0x000000);
                        });
                        document.getElementById('hintText').textContent = "Mauvais ordre ! L'ordre est: Rouge ‚Üí Bleu ‚Üí Vert ‚Üí Jaune";
                    }
                }
            });
        }

        function interactRunes() {
            puzzleObjects.runes.forEach((rune, i) => {
                if (rune.userData.collected) return;
                const dx = player.position.x - rune.position.x;
                const dz = player.position.z - rune.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    rune.userData.collected = true;
                    rune.visible = false;
                    puzzleState.runesCollected++;
                    document.getElementById('hintText').textContent = `·ö± Rune ${puzzleState.runesCollected}/4 collect√©e !`;

                    if (puzzleState.runesCollected === 4) {
                        level20ButtonHidden = false;
                        redButton.visible = true;
                        document.getElementById('hintText').textContent = "Toutes les runes collect√©es ! Le bouton appara√Æt ! üî¥";
                    }
                }
            });
        }

        function interactPillars() {
            puzzleObjects.pillars.forEach((pillar, i) => {
                const dx = player.position.x - pillar.position.x;
                const dz = player.position.z - pillar.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    pillar.userData.rotation = (pillar.userData.rotation + 1) % 4;
                    pillar.rotation.y = pillar.userData.rotation * Math.PI / 2;
                    pillar.userData.aligned = (pillar.userData.rotation === 0);

                    const allAligned = puzzleObjects.pillars.every(p => p.userData.aligned);
                    if (allAligned) {
                        level20ButtonHidden = false;
                        redButton.visible = true;
                        document.getElementById('hintText').textContent = "Tous les piliers align√©s ! Le bouton appara√Æt ! üî¥";
                    } else {
                        document.getElementById('hintText').textContent = "Aligne tous les symboles vers le nord...";
                    }
                }
            });
        }

        function interactSeed() {
            if (!puzzleObjects.seed) return;

            // Pick up seed
            if (!puzzleState.seedPlanted) {
                const dx = player.position.x - puzzleObjects.seed.position.x;
                const dz = player.position.z - puzzleObjects.seed.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    puzzleState.seedPlanted = true;
                    puzzleObjects.seed.position.set(-20, 0.3, -20); // Move to pot
                    document.getElementById('hintText').textContent = "üå± Graine plant√©e ! Trouve de l'eau...";
                }
            }
            // Water the seed
            else if (puzzleState.seedPlanted && !puzzleState.seedWatered) {
                // Check if near water
                const waterX = 0, waterZ = 30;
                const dx = player.position.x - waterX;
                const dz = player.position.z - waterZ;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    puzzleState.seedWatered = true;
                    // Grow tree at pot location
                    const tree = new THREE.Group();
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 3), new THREE.MeshLambertMaterial({ color: 0x8b4513 }));
                    trunk.position.y = 1.5;
                    tree.add(trunk);
                    const leaves = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshLambertMaterial({ color: 0x228b22 }));
                    leaves.position.y = 4;
                    tree.add(leaves);
                    tree.position.set(-20, 0, -20);
                    scene.add(tree);
                    levelObjects.push(tree);

                    puzzleObjects.seed.visible = false;
                    level20ButtonHidden = false;
                    redButton.visible = true;
                    document.getElementById('hintText').textContent = "üå≥ L'arbre a pouss√© ! Le bouton appara√Æt ! üî¥";
                }
            }
        }

        function interactUltimate() {
            // Step 1: Get key
            if (puzzleObjects.keys && puzzleObjects.keys[0] && !puzzleObjects.keys[0].userData.collected) {
                const key = puzzleObjects.keys[0];
                const dx = player.position.x - key.position.x;
                const dz = player.position.z - key.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3) {
                    key.userData.collected = true;
                    key.visible = false;
                    puzzleState.ultimateSteps = 1;
                    document.getElementById('hintText').textContent = "üîë Cl√© trouv√©e ! Ouvre la porte...";
                }
            }
            // Step 2: Open door
            else if (puzzleState.ultimateSteps === 1 && puzzleObjects.doors && puzzleObjects.doors[0]) {
                const door = puzzleObjects.doors[0];
                if (!door.userData.opened) {
                    const dx = player.position.x - door.position.x;
                    const dz = player.position.z - door.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance < 4) {
                        door.userData.opened = true;
                        door.rotation.y = -Math.PI / 2;
                        door.position.x += 1.5;
                        puzzleState.ultimateSteps = 2;
                        document.getElementById('hintText').textContent = "üö™ Porte ouverte ! Active le levier...";
                    }
                }
            }
            // Step 3: Pull lever
            else if (puzzleState.ultimateSteps === 2 && puzzleObjects.lever) {
                if (!puzzleState.leverPulled) {
                    const dx = player.position.x - puzzleObjects.lever.position.x;
                    const dz = player.position.z - puzzleObjects.lever.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance < 3) {
                        puzzleState.leverPulled = true;
                        puzzleObjects.lever.children[1].rotation.z = -0.5;
                        puzzleState.ultimateSteps = 3;
                        // Show gems
                        puzzleObjects.gems.forEach(g => g.visible = true);
                        document.getElementById('hintText').textContent = "‚öôÔ∏è Levier activ√© ! Collecte les 2 gemmes...";
                    }
                }
            }
            // Step 4: Collect gems
            else if (puzzleState.ultimateSteps === 3 && puzzleObjects.gems) {
                puzzleObjects.gems.forEach((gem, i) => {
                    if (gem.userData.collected || !gem.visible) return;
                    const dx = player.position.x - gem.position.x;
                    const dz = player.position.z - gem.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance < 3) {
                        gem.userData.collected = true;
                        gem.visible = false;
                        puzzleState.gemsCollected++;
                        document.getElementById('hintText').textContent = `üíé Gemme ${puzzleState.gemsCollected}/2 collect√©e !`;

                        if (puzzleState.gemsCollected === 2) {
                            level20ButtonHidden = false;
                            redButton.visible = true;
                            document.getElementById('hintText').textContent = "üëë √âPREUVE ULTIME COMPL√àTE ! Le bouton appara√Æt ! üî¥";
                        }
                    }
                });
            }
        }

        function startGame() {
            loadLevel();

            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('levelSelectScreen').style.display = 'none';
            document.getElementById('gameUI').style.display = 'flex';
            document.getElementById('cameraBtn').style.display = 'block';
            document.getElementById('menuBtn').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('timer').style.display = 'block';

            isPlaying = true;
            timerStart = Date.now();
            timerInterval = setInterval(updateTimer, 100);
        }

        function updateTimer() {
            const elapsed = Date.now() - timerStart;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('timer').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function changeCamera() {
            isFirstPerson = !isFirstPerson;
            if (isFirstPerson) {
                document.getElementById('cameraBtn').textContent = 'üëÅÔ∏è VUE 1√àRE PERSONNE';
                // Cacher le personnage en vue 1√®re personne
                player.visible = false;
            } else {
                document.getElementById('cameraBtn').textContent = 'üì∑ VUE 3√àME PERSONNE';
                player.visible = true;
            }
        }

        function onMouseDown(event) {
            if (event.button === 2) { // Clic droit
                isRightMouseDown = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                isRightMouseDown = false;
            }
        }

        function onMouseMove(event) {
            if (isRightMouseDown && isPlaying) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;

                // Sensibilit√© de la souris
                const sensitivity = 0.005;

                // Rotation horizontale (yaw)
                cameraYaw -= deltaX * sensitivity;

                // Rotation verticale (pitch) - limit√©e pour ne pas faire de looping
                cameraPitch += deltaY * sensitivity;
                cameraPitch = Math.max(-0.5, Math.min(1.2, cameraPitch)); // Limiter entre -0.5 et 1.2 radians

                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        function onMouseWheel(event) {
            if (!isPlaying || isFirstPerson) return; // Pas de zoom en premi√®re personne

            // Zoom avec la molette (plus rapide)
            const zoomSpeed = 2.5;
            cameraDistance += event.deltaY * 0.01 * zoomSpeed;

            // Limiter le zoom entre 3 et 12 (max r√©duit pour ne pas voir toute la map)
            cameraDistance = Math.max(3, Math.min(12, cameraDistance));
        }

        function backToMenu() {
            document.getElementById('menuScreen').style.display = 'flex';
            document.getElementById('levelSelectScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('cameraBtn').style.display = 'none';
            document.getElementById('menuBtn').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('buttonIndicator').style.display = 'none';
            document.getElementById('keyIndicator').style.display = 'none';
            document.getElementById('doorIndicator').style.display = 'none';

            isPlaying = false;
            if (timerInterval) clearInterval(timerInterval);
        }

        function nextLevel() {
            // Advance to next level, or next chapter if at level 20
            if (currentLevel < 20) {
                currentLevel++;
            } else if (currentChapter < 5) {
                // Changement de chapitre ! Afficher le menu du nouveau chapitre
                currentChapter++;
                currentLevel = 1;
                selectedLevel = currentLevel;
                selectedChapter = currentChapter;

                // Cacher le winScreen et l'UI du jeu
                document.getElementById('winScreen').style.display = 'none';
                document.getElementById('buttonIndicator').style.display = 'none';
                document.getElementById('keyIndicator').style.display = 'none';
                document.getElementById('doorIndicator').style.display = 'none';
                document.getElementById('gameUI').style.display = 'none';
                document.getElementById('cameraBtn').style.display = 'none';
                document.getElementById('menuBtn').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('timer').style.display = 'none';

                // Afficher le menu de s√©lection du nouveau chapitre
                showLevelSelect(currentChapter);
                isPlaying = false;
                return;
            } else {
                // Game complete!
                backToMenu();
                return;
            }

            selectedLevel = currentLevel;
            selectedChapter = currentChapter;

            // IMPORTANT: R√©initialiser canPressButton pour √©viter le bug de victoire instantan√©e
            canPressButton = false;

            // Cacher le winScreen AVANT de commencer
            document.getElementById('winScreen').style.display = 'none';
            document.getElementById('buttonIndicator').style.display = 'none';
            document.getElementById('keyIndicator').style.display = 'none';
            document.getElementById('doorIndicator').style.display = 'none';

            loadLevel();

            timerStart = Date.now();
            timerInterval = setInterval(updateTimer, 100); // Relancer le timer !
            isPlaying = true;
        }

        function winLevel() {
            isPlaying = false;
            if (timerInterval) clearInterval(timerInterval);

            const elapsed = Date.now() - timerStart;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('winTime').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('winScreen').style.display = 'flex';
            document.getElementById('buttonIndicator').style.display = 'none';

            if (currentLevel >= 20) {
                document.getElementById('nextLevelBtn').textContent = 'RETOUR AU MENU';
            } else {
                document.getElementById('nextLevelBtn').textContent = 'NIVEAU SUIVANT';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (keys.hasOwnProperty(event.code)) {
                keys[event.code] = true;
            }
            if (event.code === 'Space' && isGrounded && isPlaying) {
                playerVelocity.y = jumpForce;
                isGrounded = false;
            }
            // Interagir avec cl√©/porte au niveau 20 (Entr√©e seulement pour niveau 20)
            if (event.code === 'Enter' && currentLevel === 20 && isPlaying) {
                interactLevel20();
            }
            // Passer au niveau suivant avec Entr√©e quand l'√©cran de victoire est affich√©
            if (event.code === 'Enter' && document.getElementById('winScreen').style.display === 'flex') {
                nextLevel();
            }
        }

        function onKeyUp(event) {
            if (keys.hasOwnProperty(event.code)) {
                keys[event.code] = false;
            }
        }

        function onMouseClick(event) {
            // Ignorer les clics sur les boutons UI
            if (event.target.tagName === 'BUTTON') return;

            // Clic gauche - v√©rifier si on clique SUR le bouton avec raycasting
            if (event.button === 0 && isPlaying && redButton) {
                // Raycasting pour d√©tecter si on clique sur le bouton
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                // V√©rifier si on clique sur le bouton ET qu'on est proche
                const intersects = raycaster.intersectObject(redButton, true);
                if (intersects.length > 0 && canPressButton) {
                    winLevel();
                }
            }
            // Interagir avec les puzzles du chapitre 5
            if (event.button === 0 && currentChapter === 5 && isPlaying) {
                interactPuzzle();
            }
        }

        function updatePlayer() {
            if (!isPlaying) return;

            // Calculate camera-relative movement (utilise l'angle libre de la cam√©ra)
            const angle = cameraYaw;
            let moveX = 0;
            let moveZ = 0;

            // D√©placement avec WASD uniquement
            if (keys.KeyW) {
                moveX -= Math.sin(angle);
                moveZ -= Math.cos(angle);
            }
            if (keys.KeyS) {
                moveX += Math.sin(angle);
                moveZ += Math.cos(angle);
            }
            if (keys.KeyA) {
                moveX -= Math.cos(angle);
                moveZ += Math.sin(angle);
            }
            if (keys.KeyD) {
                moveX += Math.cos(angle);
                moveZ -= Math.sin(angle);
            }

            // Rotation de la cam√©ra avec les fl√®ches
            const rotationSpeed = 0.03;
            if (keys.ArrowLeft) {
                cameraYaw += rotationSpeed;
            }
            if (keys.ArrowRight) {
                cameraYaw -= rotationSpeed;
            }
            if (keys.ArrowUp) {
                cameraPitch -= rotationSpeed;
                cameraPitch = Math.max(-0.5, Math.min(1.2, cameraPitch));
            }
            if (keys.ArrowDown) {
                cameraPitch += rotationSpeed;
                cameraPitch = Math.max(-0.5, Math.min(1.2, cameraPitch));
            }

            // Normalize and apply speed
            if (moveX !== 0 || moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX = (moveX / length) * playerSpeed;
                moveZ = (moveZ / length) * playerSpeed;

                // Rotate player to face movement direction
                player.rotation.y = Math.atan2(moveX, moveZ);
            }

            // Sauvegarde position avant mouvement
            const oldX = player.position.x;
            const oldZ = player.position.z;

            // Apply movement
            player.position.x += moveX;
            player.position.z += moveZ;

            // Apply gravity
            playerVelocity.y -= gravity;
            player.position.y += playerVelocity.y;

            // Ground collision - d√©clar√© AVANT les v√©rifications
            let groundLevel = 0;

            // === COLLISION AVEC OBJETS SOLIDES ===
            const playerRadius = 0.5; // Rayon de collision du joueur

            for (const obj of solidObjects) {
                const objHeight = obj.height || 1.5;

                // Collision rectangulaire (murs)
                if (obj.type === 'rect') {
                    const halfW = obj.width / 2 + playerRadius;
                    const halfD = obj.depth / 2 + playerRadius;
                    const dx = player.position.x - obj.x;
                    const dz = player.position.z - obj.z;

                    // V√©rifier si le joueur est dans la zone du rectangle
                    if (Math.abs(dx) < halfW && Math.abs(dz) < halfD) {
                        // Si le joueur est AU-DESSUS
                        if (player.position.y >= objHeight - 0.3) {
                            groundLevel = Math.max(groundLevel, objHeight);
                            continue;
                        }
                        // Repousser vers le c√¥t√© le plus proche
                        const overlapX = halfW - Math.abs(dx);
                        const overlapZ = halfD - Math.abs(dz);
                        if (overlapX < overlapZ) {
                            player.position.x += (dx > 0 ? overlapX : -overlapX);
                        } else {
                            player.position.z += (dz > 0 ? overlapZ : -overlapZ);
                        }
                    }
                }
                // Collision circulaire (objets ronds)
                else {
                    const dx = player.position.x - obj.x;
                    const dz = player.position.z - obj.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    const standRadius = obj.radius + playerRadius;
                    const collisionRadius = obj.radius + playerRadius;

                    if (distance < standRadius) {
                        if (player.position.y >= objHeight - 0.3) {
                            groundLevel = Math.max(groundLevel, objHeight);
                            continue;
                        }
                        if (distance < collisionRadius && distance > 0) {
                            const pushX = (dx / distance) * (collisionRadius - distance);
                            const pushZ = (dz / distance) * (collisionRadius - distance);
                            player.position.x += pushX;
                            player.position.z += pushZ;
                        }
                    }
                }
            }

            // Volcan - surface du c√¥ne tronqu√© (Chapitre 4, niveau 2 = volcano)
            const levelKey = getLevelKey(currentChapter, currentLevel);
            const currentConfig = levelConfigs[levelKey];
            if (currentConfig && currentConfig.levelType === 'volcano') {
                const distFromCenter = Math.sqrt(player.position.x * player.position.x + player.position.z * player.position.z);
                const volcanoBaseRadius = 35;
                const volcanoCraterRadius = 8;
                const volcanoHeight = 20;

                if (distFromCenter <= volcanoCraterRadius) {
                    // Dans le crat√®re (sur la lave) - surface plate au sommet
                    groundLevel = volcanoHeight;
                } else if (distFromCenter <= volcanoBaseRadius) {
                    // Sur les pentes du c√¥ne tronqu√© - interpolation lin√©aire
                    // De rayon 8 (hauteur 20) √† rayon 35 (hauteur 0)
                    groundLevel = volcanoHeight * (volcanoBaseRadius - distFromCenter) / (volcanoBaseRadius - volcanoCraterRadius);
                } else {
                    // Hors du volcan - sol plat
                    groundLevel = 0;
                }
            }

            // Check platform collisions
            if (platforms.length > 0) {
                let onPlatform = false;
                platforms.forEach(platform => {
                    let isOnPlatformArea = false;
                    let distFromCenter = 0;
                    let platformHeight = platform.y;

                    // V√©rification circulaire pour les plateformes rondes
                    if (platform.circular) {
                        // Utiliser centerX/centerZ si d√©fini, sinon 0
                        const cx = platform.centerX || 0;
                        const cz = platform.centerZ || 0;
                        const dx = player.position.x - cx;
                        const dz = player.position.z - cz;
                        distFromCenter = Math.sqrt(dx * dx + dz * dz);
                        isOnPlatformArea = distFromCenter <= platform.radius;

                        // Pour les d√¥mes (collines), calculer la hauteur selon la distance du centre
                        if (platform.isDome && isOnPlatformArea) {
                            const r = platform.domeRadius;
                            // Hauteur d'une h√©misph√®re: sqrt(r¬≤ - d¬≤)
                            platformHeight = Math.sqrt(Math.max(0, r * r - distFromCenter * distFromCenter));
                        }
                    } else {
                        // V√©rification rectangulaire standard
                        isOnPlatformArea = player.position.x >= platform.minX && player.position.x <= platform.maxX &&
                            player.position.z >= platform.minZ && player.position.z <= platform.maxZ;
                    }

                    // Si on est sur la plateforme
                    if (isOnPlatformArea) {
                        groundLevel = Math.max(groundLevel, platformHeight);
                        onPlatform = true;
                    }
                });

                // If not on any platform and below main ground
                if (!onPlatform && player.position.y < -10) {
                    // Reset to start
                    player.position.set(0, 1, 0);
                    playerVelocity.y = 0;
                }
            }

            if (player.position.y <= groundLevel) {
                player.position.y = groundLevel;
                playerVelocity.y = 0;
                isGrounded = true;
            }

            // Invisible barriers (keep player in bounds)
            const bounds = 48;
            player.position.x = Math.max(-bounds, Math.min(bounds, player.position.x));
            player.position.z = Math.max(-bounds, Math.min(bounds, player.position.z));
        }

        function updateCamera() {
            if (isFirstPerson) {
                // Vue premi√®re personne - cam√©ra dans la t√™te du personnage
                const targetX = player.position.x;
                const targetY = player.position.y + 2.5; // Hauteur des yeux
                const targetZ = player.position.z;

                camera.position.x += (targetX - camera.position.x) * 0.3;
                camera.position.y += (targetY - camera.position.y) * 0.3;
                camera.position.z += (targetZ - camera.position.z) * 0.3;

                // Regarder dans la direction de la cam√©ra
                const lookX = player.position.x - Math.sin(cameraYaw) * 10;
                const lookY = player.position.y + 2.5 - cameraPitch * 5;
                const lookZ = player.position.z - Math.cos(cameraYaw) * 10;
                camera.lookAt(lookX, lookY, lookZ);
            } else {
                // Vue troisi√®me personne - cam√©ra derri√®re le personnage
                const horizontalDist = cameraDistance * Math.cos(cameraPitch);
                const verticalDist = cameraDistance * Math.sin(cameraPitch);

                const targetX = player.position.x + Math.sin(cameraYaw) * horizontalDist;
                const targetZ = player.position.z + Math.cos(cameraYaw) * horizontalDist;
                const targetY = player.position.y + cameraHeight + verticalDist;

                camera.position.x += (targetX - camera.position.x) * 0.1;
                camera.position.y += (targetY - camera.position.y) * 0.1;
                camera.position.z += (targetZ - camera.position.z) * 0.1;

                camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
            }
        }

        function checkButtonProximity() {
            if (!redButton || !isPlaying) return;

            // Au niveau 20, ne pas v√©rifier si le bouton est encore cach√©
            if (currentLevel === 20 && level20ButtonHidden) {
                canPressButton = false;
                return;
            }

            const dx = player.position.x - redButton.position.x;
            const dy = player.position.y - redButton.position.y;
            const dz = player.position.z - redButton.position.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (distance < 6) {
                canPressButton = true;
                // Pas de notification - le joueur doit trouver et cliquer sur le bouton
                // Animation du bouton quand on est proche (sans indiquer au joueur)
                const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.1;
                redButton.scale.set(pulse, pulse, pulse);
            } else {
                canPressButton = false;
                redButton.scale.set(1, 1, 1);
            }
        }

        function checkLevel20Proximity() {
            if (currentLevel !== 20 || !isPlaying) {
                document.getElementById('keyIndicator').style.display = 'none';
                document.getElementById('doorIndicator').style.display = 'none';
                return;
            }

            // V√©rifier proximit√© de la cl√©
            let nearKey = false;
            if (level20Key && level20Key.visible && !hasKey) {
                const dx = player.position.x - level20Key.position.x;
                const dz = player.position.z - level20Key.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < 3) nearKey = true;
            }
            document.getElementById('keyIndicator').style.display = nearKey ? 'block' : 'none';

            // V√©rifier proximit√© de la porte
            let nearDoor = false;
            if (level20Door && level20Door.visible && hasKey && !doorOpened) {
                const dx = player.position.x - level20Door.position.x;
                const dz = player.position.z - level20Door.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < 4) nearDoor = true;
            }
            document.getElementById('doorIndicator').style.display = nearDoor ? 'block' : 'none';
        }

        function animate() {
            requestAnimationFrame(animate);

            updatePlayer();
            updateWalkAnimation();
            updateCamera();
            checkButtonProximity();
            checkLevel20Proximity();

            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>

</html>